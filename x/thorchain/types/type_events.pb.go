// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: thorchain/v1/x/thorchain/types/type_events.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	common "gitlab.com/thorchain/thornode/common"
	gitlab_com_thorchain_thornode_common "gitlab.com/thorchain/thornode/common"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PendingLiquidityType int32

const (
	PendingLiquidityType_add      PendingLiquidityType = 0
	PendingLiquidityType_withdraw PendingLiquidityType = 1
)

var PendingLiquidityType_name = map[int32]string{
	0: "add",
	1: "withdraw",
}

var PendingLiquidityType_value = map[string]int32{
	"add":      0,
	"withdraw": 1,
}

func (x PendingLiquidityType) String() string {
	return proto.EnumName(PendingLiquidityType_name, int32(x))
}

func (PendingLiquidityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{0}
}

type BondType int32

const (
	BondType_bond_paid     BondType = 0
	BondType_bond_returned BondType = 1
	BondType_bond_reward   BondType = 2
	BondType_bond_cost     BondType = 3
)

var BondType_name = map[int32]string{
	0: "bond_paid",
	1: "bond_returned",
	2: "bond_reward",
	3: "bond_cost",
}

var BondType_value = map[string]int32{
	"bond_paid":     0,
	"bond_returned": 1,
	"bond_reward":   2,
	"bond_cost":     3,
}

func (x BondType) String() string {
	return proto.EnumName(BondType_name, int32(x))
}

func (BondType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{1}
}

type MintBurnSupplyType int32

const (
	MintBurnSupplyType_mint MintBurnSupplyType = 0
	MintBurnSupplyType_burn MintBurnSupplyType = 1
)

var MintBurnSupplyType_name = map[int32]string{
	0: "mint",
	1: "burn",
}

var MintBurnSupplyType_value = map[string]int32{
	"mint": 0,
	"burn": 1,
}

func (x MintBurnSupplyType) String() string {
	return proto.EnumName(MintBurnSupplyType_name, int32(x))
}

func (MintBurnSupplyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{2}
}

type PoolMod struct {
	Asset    common.Asset                            `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset"`
	RuneAmt  github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,2,opt,name=rune_amt,json=runeAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"rune_amt"`
	RuneAdd  bool                                    `protobuf:"varint,3,opt,name=rune_add,json=runeAdd,proto3" json:"rune_add,omitempty"`
	AssetAmt github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,4,opt,name=asset_amt,json=assetAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"asset_amt"`
	AssetAdd bool                                    `protobuf:"varint,5,opt,name=asset_add,json=assetAdd,proto3" json:"asset_add,omitempty"`
}

func (m *PoolMod) Reset()         { *m = PoolMod{} }
func (m *PoolMod) String() string { return proto.CompactTextString(m) }
func (*PoolMod) ProtoMessage()    {}
func (*PoolMod) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{0}
}
func (m *PoolMod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolMod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolMod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolMod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolMod.Merge(m, src)
}
func (m *PoolMod) XXX_Size() int {
	return m.Size()
}
func (m *PoolMod) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolMod.DiscardUnknown(m)
}

var xxx_messageInfo_PoolMod proto.InternalMessageInfo

func (m *PoolMod) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *PoolMod) GetRuneAdd() bool {
	if m != nil {
		return m.RuneAdd
	}
	return false
}

func (m *PoolMod) GetAssetAdd() bool {
	if m != nil {
		return m.AssetAdd
	}
	return false
}

type EventLimitOrder struct {
	Source common.Coin                               `protobuf:"bytes,1,opt,name=source,proto3" json:"source"`
	Target common.Coin                               `protobuf:"bytes,2,opt,name=target,proto3" json:"target"`
	TxID   gitlab_com_thorchain_thornode_common.TxID `protobuf:"bytes,3,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventLimitOrder) Reset()         { *m = EventLimitOrder{} }
func (m *EventLimitOrder) String() string { return proto.CompactTextString(m) }
func (*EventLimitOrder) ProtoMessage()    {}
func (*EventLimitOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{1}
}
func (m *EventLimitOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLimitOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLimitOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLimitOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLimitOrder.Merge(m, src)
}
func (m *EventLimitOrder) XXX_Size() int {
	return m.Size()
}
func (m *EventLimitOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLimitOrder.DiscardUnknown(m)
}

var xxx_messageInfo_EventLimitOrder proto.InternalMessageInfo

func (m *EventLimitOrder) GetSource() common.Coin {
	if m != nil {
		return m.Source
	}
	return common.Coin{}
}

func (m *EventLimitOrder) GetTarget() common.Coin {
	if m != nil {
		return m.Target
	}
	return common.Coin{}
}

func (m *EventLimitOrder) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventStreamingSwap struct {
	TxID              gitlab_com_thorchain_thornode_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
	Interval          uint64                                    `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	Quantity          uint64                                    `protobuf:"varint,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Count             uint64                                    `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	LastHeight        int64                                     `protobuf:"varint,5,opt,name=last_height,json=lastHeight,proto3" json:"last_height,omitempty"`
	TradeTarget       github_com_cosmos_cosmos_sdk_types.Uint   `protobuf:"bytes,6,opt,name=trade_target,json=tradeTarget,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"trade_target"`
	Deposit           common.Coin                               `protobuf:"bytes,7,opt,name=deposit,proto3" json:"deposit"`
	In                common.Coin                               `protobuf:"bytes,8,opt,name=in,proto3" json:"in"`
	Out               common.Coin                               `protobuf:"bytes,9,opt,name=out,proto3" json:"out"`
	FailedSwaps       []uint64                                  `protobuf:"varint,10,rep,packed,name=failed_swaps,json=failedSwaps,proto3" json:"failed_swaps,omitempty"`
	FailedSwapReasons []string                                  `protobuf:"bytes,11,rep,name=failed_swap_reasons,json=failedSwapReasons,proto3" json:"failed_swap_reasons,omitempty"`
}

func (m *EventStreamingSwap) Reset()         { *m = EventStreamingSwap{} }
func (m *EventStreamingSwap) String() string { return proto.CompactTextString(m) }
func (*EventStreamingSwap) ProtoMessage()    {}
func (*EventStreamingSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{2}
}
func (m *EventStreamingSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventStreamingSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventStreamingSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventStreamingSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventStreamingSwap.Merge(m, src)
}
func (m *EventStreamingSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventStreamingSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventStreamingSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventStreamingSwap proto.InternalMessageInfo

func (m *EventStreamingSwap) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventStreamingSwap) GetInterval() uint64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *EventStreamingSwap) GetQuantity() uint64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *EventStreamingSwap) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *EventStreamingSwap) GetLastHeight() int64 {
	if m != nil {
		return m.LastHeight
	}
	return 0
}

func (m *EventStreamingSwap) GetDeposit() common.Coin {
	if m != nil {
		return m.Deposit
	}
	return common.Coin{}
}

func (m *EventStreamingSwap) GetIn() common.Coin {
	if m != nil {
		return m.In
	}
	return common.Coin{}
}

func (m *EventStreamingSwap) GetOut() common.Coin {
	if m != nil {
		return m.Out
	}
	return common.Coin{}
}

func (m *EventStreamingSwap) GetFailedSwaps() []uint64 {
	if m != nil {
		return m.FailedSwaps
	}
	return nil
}

func (m *EventStreamingSwap) GetFailedSwapReasons() []string {
	if m != nil {
		return m.FailedSwapReasons
	}
	return nil
}

type EventSwap struct {
	Pool                  common.Asset                            `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	SwapTarget            github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,2,opt,name=swap_target,json=swapTarget,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"swap_target"`
	SwapSlip              github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,3,opt,name=swap_slip,json=swapSlip,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"swap_slip"`
	LiquidityFee          github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,4,opt,name=liquidity_fee,json=liquidityFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"liquidity_fee"`
	LiquidityFeeInRune    github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,5,opt,name=liquidity_fee_in_rune,json=liquidityFeeInRune,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"liquidity_fee_in_rune"`
	InTx                  common.Tx                               `protobuf:"bytes,6,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	OutTxs                common.Tx                               `protobuf:"bytes,7,opt,name=out_txs,json=outTxs,proto3" json:"out_txs"`
	EmitAsset             common.Coin                             `protobuf:"bytes,8,opt,name=emit_asset,json=emitAsset,proto3" json:"emit_asset"`
	SynthUnits            github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,9,opt,name=synth_units,json=synthUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"synth_units"`
	StreamingSwapQuantity uint64                                  `protobuf:"varint,10,opt,name=streaming_swap_quantity,json=streamingSwapQuantity,proto3" json:"streaming_swap_quantity,omitempty"`
	StreamingSwapCount    uint64                                  `protobuf:"varint,11,opt,name=streaming_swap_count,json=streamingSwapCount,proto3" json:"streaming_swap_count,omitempty"`
	PoolSlip              github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,12,opt,name=pool_slip,json=poolSlip,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"pool_slip"`
}

func (m *EventSwap) Reset()         { *m = EventSwap{} }
func (m *EventSwap) String() string { return proto.CompactTextString(m) }
func (*EventSwap) ProtoMessage()    {}
func (*EventSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{3}
}
func (m *EventSwap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwap.Merge(m, src)
}
func (m *EventSwap) XXX_Size() int {
	return m.Size()
}
func (m *EventSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwap.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwap proto.InternalMessageInfo

func (m *EventSwap) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventSwap) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

func (m *EventSwap) GetOutTxs() common.Tx {
	if m != nil {
		return m.OutTxs
	}
	return common.Tx{}
}

func (m *EventSwap) GetEmitAsset() common.Coin {
	if m != nil {
		return m.EmitAsset
	}
	return common.Coin{}
}

func (m *EventSwap) GetStreamingSwapQuantity() uint64 {
	if m != nil {
		return m.StreamingSwapQuantity
	}
	return 0
}

func (m *EventSwap) GetStreamingSwapCount() uint64 {
	if m != nil {
		return m.StreamingSwapCount
	}
	return 0
}

type EventAddLiquidity struct {
	Pool          common.Asset                                 `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	ProviderUnits github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,2,opt,name=provider_units,json=providerUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"provider_units"`
	RuneAddress   gitlab_com_thorchain_thornode_common.Address `protobuf:"bytes,3,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"rune_address,omitempty"`
	RuneAmount    github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,4,opt,name=rune_amount,json=runeAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"rune_amount"`
	AssetAmount   github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,5,opt,name=asset_amount,json=assetAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"asset_amount"`
	RuneTxID      gitlab_com_thorchain_thornode_common.TxID    `protobuf:"bytes,6,opt,name=rune_tx_id,json=runeTxId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"rune_tx_id,omitempty"`
	AssetTxID     gitlab_com_thorchain_thornode_common.TxID    `protobuf:"bytes,7,opt,name=asset_tx_id,json=assetTxId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"asset_tx_id,omitempty"`
	AssetAddress  gitlab_com_thorchain_thornode_common.Address `protobuf:"bytes,8,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"asset_address,omitempty"`
}

func (m *EventAddLiquidity) Reset()         { *m = EventAddLiquidity{} }
func (m *EventAddLiquidity) String() string { return proto.CompactTextString(m) }
func (*EventAddLiquidity) ProtoMessage()    {}
func (*EventAddLiquidity) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{4}
}
func (m *EventAddLiquidity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAddLiquidity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAddLiquidity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAddLiquidity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAddLiquidity.Merge(m, src)
}
func (m *EventAddLiquidity) XXX_Size() int {
	return m.Size()
}
func (m *EventAddLiquidity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAddLiquidity.DiscardUnknown(m)
}

var xxx_messageInfo_EventAddLiquidity proto.InternalMessageInfo

func (m *EventAddLiquidity) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventAddLiquidity) GetRuneAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventAddLiquidity) GetRuneTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.RuneTxID
	}
	return ""
}

func (m *EventAddLiquidity) GetAssetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.AssetTxID
	}
	return ""
}

func (m *EventAddLiquidity) GetAssetAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

type EventWithdraw struct {
	Pool              common.Asset                            `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	ProviderUnits     github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,2,opt,name=provider_units,json=providerUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"provider_units"`
	BasisPoints       int64                                   `protobuf:"varint,3,opt,name=basis_points,json=basisPoints,proto3" json:"basis_points,omitempty"`
	Asymmetry         github_com_cosmos_cosmos_sdk_types.Dec  `protobuf:"bytes,4,opt,name=asymmetry,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"asymmetry"`
	InTx              common.Tx                               `protobuf:"bytes,5,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	EmitAsset         github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,6,opt,name=emit_asset,json=emitAsset,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"emit_asset"`
	EmitRune          github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,7,opt,name=emit_rune,json=emitRune,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"emit_rune"`
	ImpLossProtection github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,8,opt,name=imp_loss_protection,json=impLossProtection,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"imp_loss_protection"`
}

func (m *EventWithdraw) Reset()         { *m = EventWithdraw{} }
func (m *EventWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventWithdraw) ProtoMessage()    {}
func (*EventWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{5}
}
func (m *EventWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventWithdraw.Merge(m, src)
}
func (m *EventWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventWithdraw proto.InternalMessageInfo

func (m *EventWithdraw) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventWithdraw) GetBasisPoints() int64 {
	if m != nil {
		return m.BasisPoints
	}
	return 0
}

func (m *EventWithdraw) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventPendingLiquidity struct {
	Pool         common.Asset                                 `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	PendingType  PendingLiquidityType                         `protobuf:"varint,2,opt,name=pending_type,json=pendingType,proto3,enum=types.PendingLiquidityType" json:"pending_type,omitempty"`
	RuneAddress  gitlab_com_thorchain_thornode_common.Address `protobuf:"bytes,3,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"rune_address,omitempty"`
	RuneAmount   github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,4,opt,name=rune_amount,json=runeAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"rune_amount"`
	AssetAddress gitlab_com_thorchain_thornode_common.Address `protobuf:"bytes,5,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"asset_address,omitempty"`
	AssetAmount  github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,6,opt,name=asset_amount,json=assetAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"asset_amount"`
	RuneTxID     gitlab_com_thorchain_thornode_common.TxID    `protobuf:"bytes,7,opt,name=rune_tx_id,json=runeTxId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"rune_tx_id,omitempty"`
	AssetTxID    gitlab_com_thorchain_thornode_common.TxID    `protobuf:"bytes,8,opt,name=asset_tx_id,json=assetTxId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"asset_tx_id,omitempty"`
}

func (m *EventPendingLiquidity) Reset()         { *m = EventPendingLiquidity{} }
func (m *EventPendingLiquidity) String() string { return proto.CompactTextString(m) }
func (*EventPendingLiquidity) ProtoMessage()    {}
func (*EventPendingLiquidity) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{6}
}
func (m *EventPendingLiquidity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPendingLiquidity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPendingLiquidity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPendingLiquidity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPendingLiquidity.Merge(m, src)
}
func (m *EventPendingLiquidity) XXX_Size() int {
	return m.Size()
}
func (m *EventPendingLiquidity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPendingLiquidity.DiscardUnknown(m)
}

var xxx_messageInfo_EventPendingLiquidity proto.InternalMessageInfo

func (m *EventPendingLiquidity) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventPendingLiquidity) GetPendingType() PendingLiquidityType {
	if m != nil {
		return m.PendingType
	}
	return PendingLiquidityType_add
}

func (m *EventPendingLiquidity) GetRuneAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventPendingLiquidity) GetAssetAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventPendingLiquidity) GetRuneTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.RuneTxID
	}
	return ""
}

func (m *EventPendingLiquidity) GetAssetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.AssetTxID
	}
	return ""
}

type EventDonate struct {
	Pool common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	InTx common.Tx    `protobuf:"bytes,2,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
}

func (m *EventDonate) Reset()         { *m = EventDonate{} }
func (m *EventDonate) String() string { return proto.CompactTextString(m) }
func (*EventDonate) ProtoMessage()    {}
func (*EventDonate) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{7}
}
func (m *EventDonate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDonate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDonate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDonate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDonate.Merge(m, src)
}
func (m *EventDonate) XXX_Size() int {
	return m.Size()
}
func (m *EventDonate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDonate.DiscardUnknown(m)
}

var xxx_messageInfo_EventDonate proto.InternalMessageInfo

func (m *EventDonate) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventDonate) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventPool struct {
	Pool   common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	Status PoolStatus   `protobuf:"varint,2,opt,name=Status,proto3,enum=types.PoolStatus" json:"Status,omitempty"`
}

func (m *EventPool) Reset()         { *m = EventPool{} }
func (m *EventPool) String() string { return proto.CompactTextString(m) }
func (*EventPool) ProtoMessage()    {}
func (*EventPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{8}
}
func (m *EventPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPool.Merge(m, src)
}
func (m *EventPool) XXX_Size() int {
	return m.Size()
}
func (m *EventPool) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPool.DiscardUnknown(m)
}

var xxx_messageInfo_EventPool proto.InternalMessageInfo

func (m *EventPool) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventPool) GetStatus() PoolStatus {
	if m != nil {
		return m.Status
	}
	return PoolStatus_UnknownPoolStatus
}

type PoolAmt struct {
	Asset  common.Asset `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset"`
	Amount int64        `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *PoolAmt) Reset()         { *m = PoolAmt{} }
func (m *PoolAmt) String() string { return proto.CompactTextString(m) }
func (*PoolAmt) ProtoMessage()    {}
func (*PoolAmt) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{9}
}
func (m *PoolAmt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolAmt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolAmt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolAmt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolAmt.Merge(m, src)
}
func (m *PoolAmt) XXX_Size() int {
	return m.Size()
}
func (m *PoolAmt) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolAmt.DiscardUnknown(m)
}

var xxx_messageInfo_PoolAmt proto.InternalMessageInfo

func (m *PoolAmt) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *PoolAmt) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type EventRewards struct {
	BondReward  github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,1,opt,name=bond_reward,json=bondReward,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"bond_reward"`
	PoolRewards []PoolAmt                               `protobuf:"bytes,2,rep,name=pool_rewards,json=poolRewards,proto3" json:"pool_rewards"`
}

func (m *EventRewards) Reset()         { *m = EventRewards{} }
func (m *EventRewards) String() string { return proto.CompactTextString(m) }
func (*EventRewards) ProtoMessage()    {}
func (*EventRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{10}
}
func (m *EventRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRewards.Merge(m, src)
}
func (m *EventRewards) XXX_Size() int {
	return m.Size()
}
func (m *EventRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRewards.DiscardUnknown(m)
}

var xxx_messageInfo_EventRewards proto.InternalMessageInfo

func (m *EventRewards) GetPoolRewards() []PoolAmt {
	if m != nil {
		return m.PoolRewards
	}
	return nil
}

type EventRefund struct {
	Code   uint32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Reason string     `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	InTx   common.Tx  `protobuf:"bytes,3,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
	Fee    common.Fee `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee"`
}

func (m *EventRefund) Reset()         { *m = EventRefund{} }
func (m *EventRefund) String() string { return proto.CompactTextString(m) }
func (*EventRefund) ProtoMessage()    {}
func (*EventRefund) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{11}
}
func (m *EventRefund) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRefund) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRefund.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRefund) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRefund.Merge(m, src)
}
func (m *EventRefund) XXX_Size() int {
	return m.Size()
}
func (m *EventRefund) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRefund.DiscardUnknown(m)
}

var xxx_messageInfo_EventRefund proto.InternalMessageInfo

func (m *EventRefund) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *EventRefund) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EventRefund) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

func (m *EventRefund) GetFee() common.Fee {
	if m != nil {
		return m.Fee
	}
	return common.Fee{}
}

type EventBond struct {
	Amount   github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,1,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"amount"`
	BondType BondType                                `protobuf:"varint,2,opt,name=bond_type,json=bondType,proto3,enum=types.BondType" json:"bond_type,omitempty"`
	TxIn     common.Tx                               `protobuf:"bytes,3,opt,name=tx_in,json=txIn,proto3" json:"tx_in"`
}

func (m *EventBond) Reset()         { *m = EventBond{} }
func (m *EventBond) String() string { return proto.CompactTextString(m) }
func (*EventBond) ProtoMessage()    {}
func (*EventBond) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{12}
}
func (m *EventBond) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBond) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBond.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBond) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBond.Merge(m, src)
}
func (m *EventBond) XXX_Size() int {
	return m.Size()
}
func (m *EventBond) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBond.DiscardUnknown(m)
}

var xxx_messageInfo_EventBond proto.InternalMessageInfo

func (m *EventBond) GetBondType() BondType {
	if m != nil {
		return m.BondType
	}
	return BondType_bond_paid
}

func (m *EventBond) GetTxIn() common.Tx {
	if m != nil {
		return m.TxIn
	}
	return common.Tx{}
}

type GasPool struct {
	Asset    common.Asset                            `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset"`
	RuneAmt  github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,2,opt,name=rune_amt,json=runeAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"rune_amt"`
	AssetAmt github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,3,opt,name=asset_amt,json=assetAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"asset_amt"`
	Count    int64                                   `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *GasPool) Reset()         { *m = GasPool{} }
func (m *GasPool) String() string { return proto.CompactTextString(m) }
func (*GasPool) ProtoMessage()    {}
func (*GasPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{13}
}
func (m *GasPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasPool.Merge(m, src)
}
func (m *GasPool) XXX_Size() int {
	return m.Size()
}
func (m *GasPool) XXX_DiscardUnknown() {
	xxx_messageInfo_GasPool.DiscardUnknown(m)
}

var xxx_messageInfo_GasPool proto.InternalMessageInfo

func (m *GasPool) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *GasPool) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type EventGas struct {
	Pools []GasPool `protobuf:"bytes,1,rep,name=pools,proto3" json:"pools"`
}

func (m *EventGas) Reset()         { *m = EventGas{} }
func (m *EventGas) String() string { return proto.CompactTextString(m) }
func (*EventGas) ProtoMessage()    {}
func (*EventGas) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{14}
}
func (m *EventGas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventGas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventGas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventGas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventGas.Merge(m, src)
}
func (m *EventGas) XXX_Size() int {
	return m.Size()
}
func (m *EventGas) XXX_DiscardUnknown() {
	xxx_messageInfo_EventGas.DiscardUnknown(m)
}

var xxx_messageInfo_EventGas proto.InternalMessageInfo

func (m *EventGas) GetPools() []GasPool {
	if m != nil {
		return m.Pools
	}
	return nil
}

type EventReserve struct {
	ReserveContributor ReserveContributor `protobuf:"bytes,1,opt,name=reserve_contributor,json=reserveContributor,proto3" json:"reserve_contributor"`
	InTx               common.Tx          `protobuf:"bytes,2,opt,name=in_tx,json=inTx,proto3" json:"in_tx"`
}

func (m *EventReserve) Reset()         { *m = EventReserve{} }
func (m *EventReserve) String() string { return proto.CompactTextString(m) }
func (*EventReserve) ProtoMessage()    {}
func (*EventReserve) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{15}
}
func (m *EventReserve) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReserve) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReserve.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventReserve) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReserve.Merge(m, src)
}
func (m *EventReserve) XXX_Size() int {
	return m.Size()
}
func (m *EventReserve) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReserve.DiscardUnknown(m)
}

var xxx_messageInfo_EventReserve proto.InternalMessageInfo

func (m *EventReserve) GetReserveContributor() ReserveContributor {
	if m != nil {
		return m.ReserveContributor
	}
	return ReserveContributor{}
}

func (m *EventReserve) GetInTx() common.Tx {
	if m != nil {
		return m.InTx
	}
	return common.Tx{}
}

type EventScheduledOutbound struct {
	OutTx TxOutItem `protobuf:"bytes,1,opt,name=out_tx,json=outTx,proto3" json:"out_tx"`
}

func (m *EventScheduledOutbound) Reset()         { *m = EventScheduledOutbound{} }
func (m *EventScheduledOutbound) String() string { return proto.CompactTextString(m) }
func (*EventScheduledOutbound) ProtoMessage()    {}
func (*EventScheduledOutbound) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{16}
}
func (m *EventScheduledOutbound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventScheduledOutbound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventScheduledOutbound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventScheduledOutbound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventScheduledOutbound.Merge(m, src)
}
func (m *EventScheduledOutbound) XXX_Size() int {
	return m.Size()
}
func (m *EventScheduledOutbound) XXX_DiscardUnknown() {
	xxx_messageInfo_EventScheduledOutbound.DiscardUnknown(m)
}

var xxx_messageInfo_EventScheduledOutbound proto.InternalMessageInfo

func (m *EventScheduledOutbound) GetOutTx() TxOutItem {
	if m != nil {
		return m.OutTx
	}
	return TxOutItem{}
}

type EventSecurity struct {
	Msg string    `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Tx  common.Tx `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx"`
}

func (m *EventSecurity) Reset()         { *m = EventSecurity{} }
func (m *EventSecurity) String() string { return proto.CompactTextString(m) }
func (*EventSecurity) ProtoMessage()    {}
func (*EventSecurity) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{17}
}
func (m *EventSecurity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSecurity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSecurity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSecurity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSecurity.Merge(m, src)
}
func (m *EventSecurity) XXX_Size() int {
	return m.Size()
}
func (m *EventSecurity) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSecurity.DiscardUnknown(m)
}

var xxx_messageInfo_EventSecurity proto.InternalMessageInfo

func (m *EventSecurity) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *EventSecurity) GetTx() common.Tx {
	if m != nil {
		return m.Tx
	}
	return common.Tx{}
}

type EventSlash struct {
	Pool        common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool"`
	SlashAmount []PoolAmt    `protobuf:"bytes,2,rep,name=slash_amount,json=slashAmount,proto3" json:"slash_amount"`
}

func (m *EventSlash) Reset()         { *m = EventSlash{} }
func (m *EventSlash) String() string { return proto.CompactTextString(m) }
func (*EventSlash) ProtoMessage()    {}
func (*EventSlash) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{18}
}
func (m *EventSlash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSlash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSlash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSlash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSlash.Merge(m, src)
}
func (m *EventSlash) XXX_Size() int {
	return m.Size()
}
func (m *EventSlash) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSlash.DiscardUnknown(m)
}

var xxx_messageInfo_EventSlash proto.InternalMessageInfo

func (m *EventSlash) GetPool() common.Asset {
	if m != nil {
		return m.Pool
	}
	return common.Asset{}
}

func (m *EventSlash) GetSlashAmount() []PoolAmt {
	if m != nil {
		return m.SlashAmount
	}
	return nil
}

type EventErrata struct {
	TxID  gitlab_com_thorchain_thornode_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
	Pools PoolMods                                  `protobuf:"bytes,2,rep,name=pools,proto3,castrepeated=PoolMods" json:"pools"`
}

func (m *EventErrata) Reset()         { *m = EventErrata{} }
func (m *EventErrata) String() string { return proto.CompactTextString(m) }
func (*EventErrata) ProtoMessage()    {}
func (*EventErrata) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{19}
}
func (m *EventErrata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventErrata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventErrata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventErrata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventErrata.Merge(m, src)
}
func (m *EventErrata) XXX_Size() int {
	return m.Size()
}
func (m *EventErrata) XXX_DiscardUnknown() {
	xxx_messageInfo_EventErrata.DiscardUnknown(m)
}

var xxx_messageInfo_EventErrata proto.InternalMessageInfo

func (m *EventErrata) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventErrata) GetPools() PoolMods {
	if m != nil {
		return m.Pools
	}
	return nil
}

type EventFee struct {
	TxID       gitlab_com_thorchain_thornode_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
	Fee        common.Fee                                `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee"`
	SynthUnits github_com_cosmos_cosmos_sdk_types.Uint   `protobuf:"bytes,3,opt,name=synth_units,json=synthUnits,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"synth_units"`
}

func (m *EventFee) Reset()         { *m = EventFee{} }
func (m *EventFee) String() string { return proto.CompactTextString(m) }
func (*EventFee) ProtoMessage()    {}
func (*EventFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{20}
}
func (m *EventFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventFee.Merge(m, src)
}
func (m *EventFee) XXX_Size() int {
	return m.Size()
}
func (m *EventFee) XXX_DiscardUnknown() {
	xxx_messageInfo_EventFee.DiscardUnknown(m)
}

var xxx_messageInfo_EventFee proto.InternalMessageInfo

func (m *EventFee) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventFee) GetFee() common.Fee {
	if m != nil {
		return m.Fee
	}
	return common.Fee{}
}

type EventOutbound struct {
	InTxID gitlab_com_thorchain_thornode_common.TxID `protobuf:"bytes,1,opt,name=in_tx_id,json=inTxId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"in_tx_id,omitempty"`
	Tx     common.Tx                                 `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx"`
}

func (m *EventOutbound) Reset()         { *m = EventOutbound{} }
func (m *EventOutbound) String() string { return proto.CompactTextString(m) }
func (*EventOutbound) ProtoMessage()    {}
func (*EventOutbound) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{21}
}
func (m *EventOutbound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventOutbound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventOutbound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventOutbound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventOutbound.Merge(m, src)
}
func (m *EventOutbound) XXX_Size() int {
	return m.Size()
}
func (m *EventOutbound) XXX_DiscardUnknown() {
	xxx_messageInfo_EventOutbound.DiscardUnknown(m)
}

var xxx_messageInfo_EventOutbound proto.InternalMessageInfo

func (m *EventOutbound) GetInTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.InTxID
	}
	return ""
}

func (m *EventOutbound) GetTx() common.Tx {
	if m != nil {
		return m.Tx
	}
	return common.Tx{}
}

type EventTssKeygenSuccess struct {
	PubKey  gitlab_com_thorchain_thornode_common.PubKey `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3,casttype=gitlab.com/thorchain/thornode/common.PubKey" json:"pub_key,omitempty"`
	Members []string                                    `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	Height  int64                                       `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *EventTssKeygenSuccess) Reset()         { *m = EventTssKeygenSuccess{} }
func (m *EventTssKeygenSuccess) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenSuccess) ProtoMessage()    {}
func (*EventTssKeygenSuccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{22}
}
func (m *EventTssKeygenSuccess) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenSuccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenSuccess.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenSuccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenSuccess.Merge(m, src)
}
func (m *EventTssKeygenSuccess) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenSuccess) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenSuccess.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenSuccess proto.InternalMessageInfo

func (m *EventTssKeygenSuccess) GetPubKey() gitlab_com_thorchain_thornode_common.PubKey {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *EventTssKeygenSuccess) GetMembers() []string {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *EventTssKeygenSuccess) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type EventTssKeygenFailure struct {
	FailReason string   `protobuf:"bytes,1,opt,name=fail_reason,json=failReason,proto3" json:"fail_reason,omitempty"`
	IsUnicast  bool     `protobuf:"varint,2,opt,name=is_unicast,json=isUnicast,proto3" json:"is_unicast,omitempty"`
	BlameNodes []string `protobuf:"bytes,3,rep,name=blame_nodes,json=blameNodes,proto3" json:"blame_nodes,omitempty"`
	Round      string   `protobuf:"bytes,4,opt,name=round,proto3" json:"round,omitempty"`
	Height     int64    `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *EventTssKeygenFailure) Reset()         { *m = EventTssKeygenFailure{} }
func (m *EventTssKeygenFailure) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenFailure) ProtoMessage()    {}
func (*EventTssKeygenFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{23}
}
func (m *EventTssKeygenFailure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenFailure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenFailure.Merge(m, src)
}
func (m *EventTssKeygenFailure) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenFailure.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenFailure proto.InternalMessageInfo

func (m *EventTssKeygenFailure) GetFailReason() string {
	if m != nil {
		return m.FailReason
	}
	return ""
}

func (m *EventTssKeygenFailure) GetIsUnicast() bool {
	if m != nil {
		return m.IsUnicast
	}
	return false
}

func (m *EventTssKeygenFailure) GetBlameNodes() []string {
	if m != nil {
		return m.BlameNodes
	}
	return nil
}

func (m *EventTssKeygenFailure) GetRound() string {
	if m != nil {
		return m.Round
	}
	return ""
}

func (m *EventTssKeygenFailure) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type EventTssKeygenMetric struct {
	PubKey           gitlab_com_thorchain_thornode_common.PubKey `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3,casttype=gitlab.com/thorchain/thornode/common.PubKey" json:"pub_key,omitempty"`
	MedianDurationMs int64                                       `protobuf:"varint,2,opt,name=median_duration_ms,json=medianDurationMs,proto3" json:"median_duration_ms,omitempty"`
}

func (m *EventTssKeygenMetric) Reset()         { *m = EventTssKeygenMetric{} }
func (m *EventTssKeygenMetric) String() string { return proto.CompactTextString(m) }
func (*EventTssKeygenMetric) ProtoMessage()    {}
func (*EventTssKeygenMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{24}
}
func (m *EventTssKeygenMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeygenMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeygenMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeygenMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeygenMetric.Merge(m, src)
}
func (m *EventTssKeygenMetric) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeygenMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeygenMetric.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeygenMetric proto.InternalMessageInfo

func (m *EventTssKeygenMetric) GetPubKey() gitlab_com_thorchain_thornode_common.PubKey {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *EventTssKeygenMetric) GetMedianDurationMs() int64 {
	if m != nil {
		return m.MedianDurationMs
	}
	return 0
}

type EventTssKeysignMetric struct {
	TxID             gitlab_com_thorchain_thornode_common.TxID `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
	MedianDurationMs int64                                     `protobuf:"varint,2,opt,name=median_duration_ms,json=medianDurationMs,proto3" json:"median_duration_ms,omitempty"`
}

func (m *EventTssKeysignMetric) Reset()         { *m = EventTssKeysignMetric{} }
func (m *EventTssKeysignMetric) String() string { return proto.CompactTextString(m) }
func (*EventTssKeysignMetric) ProtoMessage()    {}
func (*EventTssKeysignMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{25}
}
func (m *EventTssKeysignMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTssKeysignMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTssKeysignMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTssKeysignMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTssKeysignMetric.Merge(m, src)
}
func (m *EventTssKeysignMetric) XXX_Size() int {
	return m.Size()
}
func (m *EventTssKeysignMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTssKeysignMetric.DiscardUnknown(m)
}

var xxx_messageInfo_EventTssKeysignMetric proto.InternalMessageInfo

func (m *EventTssKeysignMetric) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

func (m *EventTssKeysignMetric) GetMedianDurationMs() int64 {
	if m != nil {
		return m.MedianDurationMs
	}
	return 0
}

type EventSlashPoint struct {
	NodeAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=node_address,json=nodeAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"node_address,omitempty"`
	SlashPoints int64                                         `protobuf:"varint,2,opt,name=slash_points,json=slashPoints,proto3" json:"slash_points,omitempty"`
	Reason      string                                        `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventSlashPoint) Reset()         { *m = EventSlashPoint{} }
func (m *EventSlashPoint) String() string { return proto.CompactTextString(m) }
func (*EventSlashPoint) ProtoMessage()    {}
func (*EventSlashPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{26}
}
func (m *EventSlashPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSlashPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSlashPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSlashPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSlashPoint.Merge(m, src)
}
func (m *EventSlashPoint) XXX_Size() int {
	return m.Size()
}
func (m *EventSlashPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSlashPoint.DiscardUnknown(m)
}

var xxx_messageInfo_EventSlashPoint proto.InternalMessageInfo

func (m *EventSlashPoint) GetNodeAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NodeAddress
	}
	return nil
}

func (m *EventSlashPoint) GetSlashPoints() int64 {
	if m != nil {
		return m.SlashPoints
	}
	return 0
}

func (m *EventSlashPoint) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type EventPoolBalanceChanged struct {
	PoolChange PoolMod `protobuf:"bytes,1,opt,name=pool_change,json=poolChange,proto3" json:"pool_change"`
	Reason     string  `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventPoolBalanceChanged) Reset()         { *m = EventPoolBalanceChanged{} }
func (m *EventPoolBalanceChanged) String() string { return proto.CompactTextString(m) }
func (*EventPoolBalanceChanged) ProtoMessage()    {}
func (*EventPoolBalanceChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{27}
}
func (m *EventPoolBalanceChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPoolBalanceChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPoolBalanceChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPoolBalanceChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPoolBalanceChanged.Merge(m, src)
}
func (m *EventPoolBalanceChanged) XXX_Size() int {
	return m.Size()
}
func (m *EventPoolBalanceChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPoolBalanceChanged.DiscardUnknown(m)
}

var xxx_messageInfo_EventPoolBalanceChanged proto.InternalMessageInfo

func (m *EventPoolBalanceChanged) GetPoolChange() PoolMod {
	if m != nil {
		return m.PoolChange
	}
	return PoolMod{}
}

func (m *EventPoolBalanceChanged) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// TODO remove on hard fork
type EventSwitch struct {
	ToAddress   github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=to_address,json=toAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"to_address,omitempty"`
	FromAddress gitlab_com_thorchain_thornode_common.Address  `protobuf:"bytes,2,opt,name=from_address,json=fromAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"from_address,omitempty"`
	Burn        common.Coin                                   `protobuf:"bytes,3,opt,name=burn,proto3" json:"burn"`
	TxID        gitlab_com_thorchain_thornode_common.TxID     `protobuf:"bytes,4,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventSwitch) Reset()         { *m = EventSwitch{} }
func (m *EventSwitch) String() string { return proto.CompactTextString(m) }
func (*EventSwitch) ProtoMessage()    {}
func (*EventSwitch) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{28}
}
func (m *EventSwitch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwitch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwitch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwitch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwitch.Merge(m, src)
}
func (m *EventSwitch) XXX_Size() int {
	return m.Size()
}
func (m *EventSwitch) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwitch.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwitch proto.InternalMessageInfo

func (m *EventSwitch) GetToAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.ToAddress
	}
	return nil
}

func (m *EventSwitch) GetFromAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *EventSwitch) GetBurn() common.Coin {
	if m != nil {
		return m.Burn
	}
	return common.Coin{}
}

func (m *EventSwitch) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

// TODO remove on hard fork
type EventSwitchV87 struct {
	ToAddress   github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=to_address,json=toAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"to_address,omitempty"`
	FromAddress gitlab_com_thorchain_thornode_common.Address  `protobuf:"bytes,2,opt,name=from_address,json=fromAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"from_address,omitempty"`
	Burn        common.Coin                                   `protobuf:"bytes,3,opt,name=burn,proto3" json:"burn"`
	TxID        gitlab_com_thorchain_thornode_common.TxID     `protobuf:"bytes,4,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
	Mint        github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,5,opt,name=mint,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"mint"`
}

func (m *EventSwitchV87) Reset()         { *m = EventSwitchV87{} }
func (m *EventSwitchV87) String() string { return proto.CompactTextString(m) }
func (*EventSwitchV87) ProtoMessage()    {}
func (*EventSwitchV87) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{29}
}
func (m *EventSwitchV87) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwitchV87) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwitchV87.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwitchV87) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwitchV87.Merge(m, src)
}
func (m *EventSwitchV87) XXX_Size() int {
	return m.Size()
}
func (m *EventSwitchV87) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwitchV87.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwitchV87 proto.InternalMessageInfo

func (m *EventSwitchV87) GetToAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.ToAddress
	}
	return nil
}

func (m *EventSwitchV87) GetFromAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *EventSwitchV87) GetBurn() common.Coin {
	if m != nil {
		return m.Burn
	}
	return common.Coin{}
}

func (m *EventSwitchV87) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventMintBurn struct {
	Supply MintBurnSupplyType                      `protobuf:"varint,1,opt,name=supply,proto3,enum=types.MintBurnSupplyType" json:"supply,omitempty"`
	Denom  string                                  `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Amount github_com_cosmos_cosmos_sdk_types.Uint `protobuf:"bytes,3,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"amount"`
	Reason string                                  `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventMintBurn) Reset()         { *m = EventMintBurn{} }
func (m *EventMintBurn) String() string { return proto.CompactTextString(m) }
func (*EventMintBurn) ProtoMessage()    {}
func (*EventMintBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{30}
}
func (m *EventMintBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMintBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMintBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMintBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMintBurn.Merge(m, src)
}
func (m *EventMintBurn) XXX_Size() int {
	return m.Size()
}
func (m *EventMintBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMintBurn.DiscardUnknown(m)
}

var xxx_messageInfo_EventMintBurn proto.InternalMessageInfo

func (m *EventMintBurn) GetSupply() MintBurnSupplyType {
	if m != nil {
		return m.Supply
	}
	return MintBurnSupplyType_mint
}

func (m *EventMintBurn) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *EventMintBurn) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type EventTradeAccountDeposit struct {
	Amount       github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,1,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"amount"`
	Asset        common.Asset                                 `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset"`
	AssetAddress gitlab_com_thorchain_thornode_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"asset_address,omitempty"`
	RuneAddress  gitlab_com_thorchain_thornode_common.Address `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"rune_address,omitempty"`
	TxID         gitlab_com_thorchain_thornode_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventTradeAccountDeposit) Reset()         { *m = EventTradeAccountDeposit{} }
func (m *EventTradeAccountDeposit) String() string { return proto.CompactTextString(m) }
func (*EventTradeAccountDeposit) ProtoMessage()    {}
func (*EventTradeAccountDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{31}
}
func (m *EventTradeAccountDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTradeAccountDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTradeAccountDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTradeAccountDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTradeAccountDeposit.Merge(m, src)
}
func (m *EventTradeAccountDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventTradeAccountDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTradeAccountDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventTradeAccountDeposit proto.InternalMessageInfo

func (m *EventTradeAccountDeposit) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *EventTradeAccountDeposit) GetAssetAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventTradeAccountDeposit) GetRuneAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventTradeAccountDeposit) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventTradeAccountWithdraw struct {
	Amount       github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,1,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"amount"`
	Asset        common.Asset                                 `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset"`
	AssetAddress gitlab_com_thorchain_thornode_common.Address `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"asset_address,omitempty"`
	RuneAddress  gitlab_com_thorchain_thornode_common.Address `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"rune_address,omitempty"`
	TxID         gitlab_com_thorchain_thornode_common.TxID    `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventTradeAccountWithdraw) Reset()         { *m = EventTradeAccountWithdraw{} }
func (m *EventTradeAccountWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventTradeAccountWithdraw) ProtoMessage()    {}
func (*EventTradeAccountWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{32}
}
func (m *EventTradeAccountWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTradeAccountWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTradeAccountWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTradeAccountWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTradeAccountWithdraw.Merge(m, src)
}
func (m *EventTradeAccountWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventTradeAccountWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTradeAccountWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventTradeAccountWithdraw proto.InternalMessageInfo

func (m *EventTradeAccountWithdraw) GetAsset() common.Asset {
	if m != nil {
		return m.Asset
	}
	return common.Asset{}
}

func (m *EventTradeAccountWithdraw) GetAssetAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.AssetAddress
	}
	return ""
}

func (m *EventTradeAccountWithdraw) GetRuneAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.RuneAddress
	}
	return ""
}

func (m *EventTradeAccountWithdraw) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventLoanOpen struct {
	CollateralDeposited    github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,1,opt,name=collateral_deposited,json=collateralDeposited,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"collateral_deposited"`
	CollateralAsset        common.Asset                                 `protobuf:"bytes,2,opt,name=collateral_asset,json=collateralAsset,proto3" json:"collateral_asset"`
	CollateralizationRatio github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,3,opt,name=collateralization_ratio,json=collateralizationRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"collateralization_ratio"`
	DebtIssued             github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,4,opt,name=debt_issued,json=debtIssued,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"debt_issued"`
	Owner                  gitlab_com_thorchain_thornode_common.Address `protobuf:"bytes,5,opt,name=owner,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"owner,omitempty"`
	TargetAsset            common.Asset                                 `protobuf:"bytes,6,opt,name=target_asset,json=targetAsset,proto3" json:"target_asset"`
	TxID                   gitlab_com_thorchain_thornode_common.TxID    `protobuf:"bytes,7,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventLoanOpen) Reset()         { *m = EventLoanOpen{} }
func (m *EventLoanOpen) String() string { return proto.CompactTextString(m) }
func (*EventLoanOpen) ProtoMessage()    {}
func (*EventLoanOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{33}
}
func (m *EventLoanOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLoanOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLoanOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLoanOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLoanOpen.Merge(m, src)
}
func (m *EventLoanOpen) XXX_Size() int {
	return m.Size()
}
func (m *EventLoanOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLoanOpen.DiscardUnknown(m)
}

var xxx_messageInfo_EventLoanOpen proto.InternalMessageInfo

func (m *EventLoanOpen) GetCollateralAsset() common.Asset {
	if m != nil {
		return m.CollateralAsset
	}
	return common.Asset{}
}

func (m *EventLoanOpen) GetOwner() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventLoanOpen) GetTargetAsset() common.Asset {
	if m != nil {
		return m.TargetAsset
	}
	return common.Asset{}
}

func (m *EventLoanOpen) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventLoanRepayment struct {
	CollateralWithdrawn github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,1,opt,name=collateral_withdrawn,json=collateralWithdrawn,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"collateral_withdrawn"`
	CollateralAsset     common.Asset                                 `protobuf:"bytes,2,opt,name=collateral_asset,json=collateralAsset,proto3" json:"collateral_asset"`
	DebtRepaid          github_com_cosmos_cosmos_sdk_types.Uint      `protobuf:"bytes,3,opt,name=debt_repaid,json=debtRepaid,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"debt_repaid"`
	Owner               gitlab_com_thorchain_thornode_common.Address `protobuf:"bytes,4,opt,name=owner,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"owner,omitempty"`
	TxID                gitlab_com_thorchain_thornode_common.TxID    `protobuf:"bytes,7,opt,name=tx_id,json=txId,proto3,casttype=gitlab.com/thorchain/thornode/common.TxID" json:"tx_id,omitempty"`
}

func (m *EventLoanRepayment) Reset()         { *m = EventLoanRepayment{} }
func (m *EventLoanRepayment) String() string { return proto.CompactTextString(m) }
func (*EventLoanRepayment) ProtoMessage()    {}
func (*EventLoanRepayment) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{34}
}
func (m *EventLoanRepayment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventLoanRepayment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventLoanRepayment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventLoanRepayment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventLoanRepayment.Merge(m, src)
}
func (m *EventLoanRepayment) XXX_Size() int {
	return m.Size()
}
func (m *EventLoanRepayment) XXX_DiscardUnknown() {
	xxx_messageInfo_EventLoanRepayment.DiscardUnknown(m)
}

var xxx_messageInfo_EventLoanRepayment proto.InternalMessageInfo

func (m *EventLoanRepayment) GetCollateralAsset() common.Asset {
	if m != nil {
		return m.CollateralAsset
	}
	return common.Asset{}
}

func (m *EventLoanRepayment) GetOwner() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventLoanRepayment) GetTxID() gitlab_com_thorchain_thornode_common.TxID {
	if m != nil {
		return m.TxID
	}
	return ""
}

type EventTHORName struct {
	Name            string                                        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Chain           gitlab_com_thorchain_thornode_common.Chain    `protobuf:"bytes,2,opt,name=chain,proto3,casttype=gitlab.com/thorchain/thornode/common.Chain" json:"chain,omitempty"`
	Address         gitlab_com_thorchain_thornode_common.Address  `protobuf:"bytes,3,opt,name=address,proto3,casttype=gitlab.com/thorchain/thornode/common.Address" json:"address,omitempty"`
	RegistrationFee github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,4,opt,name=registration_fee,json=registrationFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"registration_fee"`
	FundAmt         github_com_cosmos_cosmos_sdk_types.Uint       `protobuf:"bytes,5,opt,name=fund_amt,json=fundAmt,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Uint" json:"fund_amt"`
	Expire          int64                                         `protobuf:"varint,6,opt,name=expire,proto3" json:"expire,omitempty"`
	Owner           github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,7,opt,name=owner,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"owner,omitempty"`
}

func (m *EventTHORName) Reset()         { *m = EventTHORName{} }
func (m *EventTHORName) String() string { return proto.CompactTextString(m) }
func (*EventTHORName) ProtoMessage()    {}
func (*EventTHORName) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{35}
}
func (m *EventTHORName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventTHORName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventTHORName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventTHORName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventTHORName.Merge(m, src)
}
func (m *EventTHORName) XXX_Size() int {
	return m.Size()
}
func (m *EventTHORName) XXX_DiscardUnknown() {
	xxx_messageInfo_EventTHORName.DiscardUnknown(m)
}

var xxx_messageInfo_EventTHORName proto.InternalMessageInfo

func (m *EventTHORName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventTHORName) GetChain() gitlab_com_thorchain_thornode_common.Chain {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *EventTHORName) GetAddress() gitlab_com_thorchain_thornode_common.Address {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *EventTHORName) GetExpire() int64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *EventTHORName) GetOwner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Owner
	}
	return nil
}

type EventSetMimir struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *EventSetMimir) Reset()         { *m = EventSetMimir{} }
func (m *EventSetMimir) String() string { return proto.CompactTextString(m) }
func (*EventSetMimir) ProtoMessage()    {}
func (*EventSetMimir) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{36}
}
func (m *EventSetMimir) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetMimir) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetMimir.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetMimir) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetMimir.Merge(m, src)
}
func (m *EventSetMimir) XXX_Size() int {
	return m.Size()
}
func (m *EventSetMimir) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetMimir.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetMimir proto.InternalMessageInfo

func (m *EventSetMimir) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *EventSetMimir) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type EventSetNodeMimir struct {
	Key     string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value   string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *EventSetNodeMimir) Reset()         { *m = EventSetNodeMimir{} }
func (m *EventSetNodeMimir) String() string { return proto.CompactTextString(m) }
func (*EventSetNodeMimir) ProtoMessage()    {}
func (*EventSetNodeMimir) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{37}
}
func (m *EventSetNodeMimir) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSetNodeMimir) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSetNodeMimir.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSetNodeMimir) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSetNodeMimir.Merge(m, src)
}
func (m *EventSetNodeMimir) XXX_Size() int {
	return m.Size()
}
func (m *EventSetNodeMimir) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSetNodeMimir.DiscardUnknown(m)
}

var xxx_messageInfo_EventSetNodeMimir proto.InternalMessageInfo

func (m *EventSetNodeMimir) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *EventSetNodeMimir) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *EventSetNodeMimir) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type EventVersion struct {
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *EventVersion) Reset()         { *m = EventVersion{} }
func (m *EventVersion) String() string { return proto.CompactTextString(m) }
func (*EventVersion) ProtoMessage()    {}
func (*EventVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_00fa6e06b539fddf, []int{38}
}
func (m *EventVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventVersion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventVersion.Merge(m, src)
}
func (m *EventVersion) XXX_Size() int {
	return m.Size()
}
func (m *EventVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_EventVersion.DiscardUnknown(m)
}

var xxx_messageInfo_EventVersion proto.InternalMessageInfo

func (m *EventVersion) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func init() {
	proto.RegisterEnum("types.PendingLiquidityType", PendingLiquidityType_name, PendingLiquidityType_value)
	proto.RegisterEnum("types.BondType", BondType_name, BondType_value)
	proto.RegisterEnum("types.MintBurnSupplyType", MintBurnSupplyType_name, MintBurnSupplyType_value)
	proto.RegisterType((*PoolMod)(nil), "types.PoolMod")
	proto.RegisterType((*EventLimitOrder)(nil), "types.EventLimitOrder")
	proto.RegisterType((*EventStreamingSwap)(nil), "types.EventStreamingSwap")
	proto.RegisterType((*EventSwap)(nil), "types.EventSwap")
	proto.RegisterType((*EventAddLiquidity)(nil), "types.EventAddLiquidity")
	proto.RegisterType((*EventWithdraw)(nil), "types.EventWithdraw")
	proto.RegisterType((*EventPendingLiquidity)(nil), "types.EventPendingLiquidity")
	proto.RegisterType((*EventDonate)(nil), "types.EventDonate")
	proto.RegisterType((*EventPool)(nil), "types.EventPool")
	proto.RegisterType((*PoolAmt)(nil), "types.PoolAmt")
	proto.RegisterType((*EventRewards)(nil), "types.EventRewards")
	proto.RegisterType((*EventRefund)(nil), "types.EventRefund")
	proto.RegisterType((*EventBond)(nil), "types.EventBond")
	proto.RegisterType((*GasPool)(nil), "types.GasPool")
	proto.RegisterType((*EventGas)(nil), "types.EventGas")
	proto.RegisterType((*EventReserve)(nil), "types.EventReserve")
	proto.RegisterType((*EventScheduledOutbound)(nil), "types.EventScheduledOutbound")
	proto.RegisterType((*EventSecurity)(nil), "types.EventSecurity")
	proto.RegisterType((*EventSlash)(nil), "types.EventSlash")
	proto.RegisterType((*EventErrata)(nil), "types.EventErrata")
	proto.RegisterType((*EventFee)(nil), "types.EventFee")
	proto.RegisterType((*EventOutbound)(nil), "types.EventOutbound")
	proto.RegisterType((*EventTssKeygenSuccess)(nil), "types.EventTssKeygenSuccess")
	proto.RegisterType((*EventTssKeygenFailure)(nil), "types.EventTssKeygenFailure")
	proto.RegisterType((*EventTssKeygenMetric)(nil), "types.EventTssKeygenMetric")
	proto.RegisterType((*EventTssKeysignMetric)(nil), "types.EventTssKeysignMetric")
	proto.RegisterType((*EventSlashPoint)(nil), "types.EventSlashPoint")
	proto.RegisterType((*EventPoolBalanceChanged)(nil), "types.EventPoolBalanceChanged")
	proto.RegisterType((*EventSwitch)(nil), "types.EventSwitch")
	proto.RegisterType((*EventSwitchV87)(nil), "types.EventSwitchV87")
	proto.RegisterType((*EventMintBurn)(nil), "types.EventMintBurn")
	proto.RegisterType((*EventTradeAccountDeposit)(nil), "types.EventTradeAccountDeposit")
	proto.RegisterType((*EventTradeAccountWithdraw)(nil), "types.EventTradeAccountWithdraw")
	proto.RegisterType((*EventLoanOpen)(nil), "types.EventLoanOpen")
	proto.RegisterType((*EventLoanRepayment)(nil), "types.EventLoanRepayment")
	proto.RegisterType((*EventTHORName)(nil), "types.EventTHORName")
	proto.RegisterType((*EventSetMimir)(nil), "types.EventSetMimir")
	proto.RegisterType((*EventSetNodeMimir)(nil), "types.EventSetNodeMimir")
	proto.RegisterType((*EventVersion)(nil), "types.EventVersion")
}

func init() {
	proto.RegisterFile("thorchain/v1/x/thorchain/types/type_events.proto", fileDescriptor_00fa6e06b539fddf)
}

var fileDescriptor_00fa6e06b539fddf = []byte{
	// 2569 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x4d, 0x6c, 0x24, 0x47,
	0x15, 0xf6, 0x4c, 0xcf, 0xef, 0x9b, 0xf1, 0xee, 0x6c, 0xad, 0x93, 0x4c, 0x12, 0xe1, 0x71, 0x1a,
	0x48, 0xbc, 0x66, 0xd7, 0xce, 0x2e, 0xca, 0x2e, 0x20, 0x11, 0xc9, 0x3f, 0xd9, 0x8d, 0x13, 0x3b,
	0xeb, 0xb4, 0xbd, 0x89, 0x14, 0x09, 0xb5, 0x7a, 0xa6, 0xcb, 0x33, 0xa5, 0x4c, 0x57, 0x4d, 0xba,
	0xaa, 0xed, 0x31, 0x67, 0x48, 0x6e, 0x08, 0xc4, 0x09, 0x21, 0x38, 0x70, 0xe0, 0xef, 0xce, 0x01,
	0x21, 0x71, 0xce, 0x05, 0x29, 0x47, 0xc4, 0xc1, 0x20, 0x2f, 0x67, 0xc4, 0x79, 0x4f, 0xa8, 0x7e,
	0xba, 0x67, 0xc6, 0x5e, 0x3b, 0xe3, 0x9e, 0x81, 0x08, 0x29, 0x17, 0xbb, 0xab, 0xfa, 0xd5, 0x57,
	0x3f, 0xef, 0x7b, 0xaf, 0xde, 0x7b, 0x3d, 0xf0, 0xaa, 0xe8, 0xb0, 0xb0, 0xd5, 0xf1, 0x08, 0x5d,
	0x39, 0xb8, 0xbd, 0xd2, 0x5f, 0x19, 0x34, 0xc5, 0x51, 0x0f, 0x73, 0xf5, 0xd7, 0xc5, 0x07, 0x98,
	0x0a, 0xbe, 0xdc, 0x0b, 0x99, 0x60, 0x28, 0xaf, 0x5e, 0xbc, 0xb0, 0x30, 0x32, 0xb0, 0xc5, 0x82,
	0x80, 0x51, 0xf3, 0x4f, 0x0b, 0xbe, 0xb0, 0x3c, 0x0e, 0x74, 0x8f, 0xb1, 0xae, 0x91, 0xff, 0xee,
	0x38, 0xf2, 0x21, 0xe6, 0x38, 0x3c, 0xc0, 0x6e, 0x8b, 0x51, 0x11, 0x92, 0x66, 0x24, 0x58, 0x68,
	0x86, 0x8f, 0xb5, 0x13, 0xd1, 0x77, 0x59, 0x24, 0xcc, 0x88, 0xb9, 0x36, 0x6b, 0x33, 0xf5, 0xb8,
	0x22, 0x9f, 0x74, 0xaf, 0xfd, 0x71, 0x16, 0x8a, 0x3b, 0x8c, 0x75, 0xb7, 0x99, 0x8f, 0x6e, 0x40,
	0xde, 0xe3, 0x1c, 0x8b, 0x7a, 0x66, 0x21, 0xb3, 0x58, 0xb9, 0x33, 0xbb, 0x6c, 0x36, 0xb8, 0x2a,
	0x3b, 0xd7, 0x72, 0x9f, 0x1e, 0x37, 0x66, 0x1c, 0x2d, 0x81, 0xde, 0x82, 0x52, 0x18, 0x51, 0xec,
	0x7a, 0x81, 0xa8, 0x67, 0x17, 0x32, 0x8b, 0xe5, 0xb5, 0x15, 0xf9, 0xfa, 0x6f, 0xc7, 0x8d, 0x57,
	0xda, 0x44, 0x74, 0xa2, 0xa6, 0x1c, 0xbb, 0xd2, 0x62, 0x3c, 0x60, 0xdc, 0xfc, 0xbb, 0xc5, 0xfd,
	0x0f, 0xf5, 0xe2, 0x96, 0x1f, 0x11, 0x2a, 0x9c, 0xa2, 0x04, 0x58, 0x0d, 0x04, 0x7a, 0x3e, 0xc6,
	0xf2, 0xfd, 0xba, 0xb5, 0x90, 0x59, 0x2c, 0x99, 0x57, 0xbe, 0x8f, 0xb6, 0xa0, 0xac, 0xe6, 0x53,
	0xf3, 0xe4, 0xd2, 0xcd, 0x53, 0x52, 0x08, 0x72, 0xa2, 0x17, 0x13, 0x34, 0xdf, 0xaf, 0xe7, 0xd5,
	0x4c, 0xe6, 0xa5, 0xef, 0xdb, 0x7f, 0xc8, 0xc0, 0xd5, 0x37, 0xa4, 0xe6, 0xb7, 0x48, 0x40, 0xc4,
	0xc3, 0xd0, 0xc7, 0x21, 0x5a, 0x82, 0x02, 0x67, 0x51, 0xd8, 0xc2, 0xe6, 0x44, 0xaa, 0xf1, 0x89,
	0xac, 0x33, 0x42, 0xcd, 0x81, 0x18, 0x09, 0x29, 0x2b, 0xbc, 0xb0, 0x8d, 0xf5, 0x79, 0x9c, 0x23,
	0xab, 0x25, 0xd0, 0x5b, 0x90, 0x17, 0x7d, 0x97, 0xe8, 0xed, 0x96, 0xd7, 0x5e, 0x3b, 0x39, 0x6e,
	0xe4, 0xf6, 0xfa, 0x9b, 0x1b, 0x4f, 0x8e, 0x1b, 0x37, 0xda, 0x44, 0x74, 0x3d, 0xbd, 0xad, 0x21,
	0x9d, 0x76, 0x58, 0x48, 0x99, 0x8f, 0x63, 0xca, 0x49, 0x61, 0x27, 0x27, 0xfa, 0x9b, 0xbe, 0xfd,
	0x2f, 0x0b, 0x90, 0x5a, 0xf7, 0xae, 0x08, 0xb1, 0x17, 0x10, 0xda, 0xde, 0x3d, 0xf4, 0x7a, 0x83,
	0x29, 0x32, 0x13, 0x4f, 0x81, 0x5e, 0x80, 0x12, 0xa1, 0x02, 0x87, 0x07, 0x5e, 0x57, 0x6d, 0x2e,
	0xe7, 0x24, 0x6d, 0xf9, 0xee, 0xa3, 0xc8, 0xa3, 0x82, 0x88, 0x23, 0xb5, 0x9b, 0x9c, 0x93, 0xb4,
	0xd1, 0x1c, 0xe4, 0x5b, 0x2c, 0xa2, 0x5a, 0x73, 0x39, 0x47, 0x37, 0x50, 0x03, 0x2a, 0x5d, 0x8f,
	0x0b, 0xb7, 0x83, 0x49, 0xbb, 0x23, 0x94, 0x1e, 0x2c, 0x07, 0x64, 0xd7, 0x9b, 0xaa, 0x07, 0x39,
	0x50, 0x15, 0xa1, 0xe7, 0x63, 0xd7, 0x9c, 0x67, 0x21, 0x9d, 0xde, 0x2b, 0x0a, 0x64, 0x4f, 0x9f,
	0xf8, 0x4d, 0x28, 0xfa, 0xb8, 0xc7, 0x38, 0x11, 0xf5, 0xe2, 0xb9, 0xea, 0x89, 0x45, 0x90, 0x0d,
	0x59, 0x42, 0xeb, 0xa5, 0x73, 0x05, 0xb3, 0x84, 0xa2, 0xaf, 0x81, 0xc5, 0x22, 0x51, 0x2f, 0x9f,
	0x2b, 0x24, 0x5f, 0xa3, 0x97, 0xa0, 0xba, 0xef, 0x91, 0x2e, 0xf6, 0x5d, 0x7e, 0xe8, 0xf5, 0x78,
	0x1d, 0x16, 0xac, 0xc5, 0x9c, 0x53, 0xd1, 0x7d, 0x52, 0x51, 0x1c, 0x2d, 0xc3, 0xf5, 0x21, 0x11,
	0x37, 0xc4, 0x1e, 0x67, 0x94, 0xd7, 0x2b, 0x0b, 0xd6, 0x62, 0xd9, 0xb9, 0x36, 0x90, 0x74, 0xf4,
	0x0b, 0xfb, 0x17, 0x05, 0x28, 0x6b, 0x85, 0x4b, 0x3d, 0xbf, 0x02, 0x39, 0xe9, 0x54, 0x2e, 0x32,
	0x59, 0x25, 0x80, 0x76, 0xa0, 0xa2, 0xf0, 0x87, 0x48, 0x9a, 0xe2, 0x50, 0x41, 0x62, 0x98, 0x33,
	0xdd, 0x82, 0xb2, 0x42, 0xe4, 0x5d, 0xd2, 0x33, 0x4c, 0xbe, 0xbc, 0x71, 0x4a, 0x84, 0xdd, 0x2e,
	0xe9, 0xa1, 0x3d, 0x98, 0xed, 0x92, 0x8f, 0x22, 0xe2, 0x13, 0x71, 0xe4, 0xee, 0x63, 0x9c, 0xd6,
	0xdc, 0xab, 0x09, 0xca, 0x7d, 0x8c, 0x51, 0x13, 0x9e, 0x19, 0x41, 0x75, 0x09, 0x75, 0xa5, 0x73,
	0x51, 0xb4, 0x4b, 0x81, 0x8e, 0x86, 0xd1, 0x37, 0xa9, 0x13, 0x51, 0x8c, 0xbe, 0x0e, 0x79, 0x42,
	0x5d, 0xd1, 0x57, 0x44, 0xad, 0xdc, 0x81, 0xe5, 0xc4, 0x82, 0x62, 0x05, 0x10, 0xba, 0xd7, 0x47,
	0x37, 0xa0, 0xc8, 0x22, 0xe1, 0x8a, 0x3e, 0x37, 0x14, 0x3c, 0x2b, 0x58, 0x60, 0x91, 0xd8, 0xeb,
	0x73, 0x74, 0x1b, 0x00, 0x07, 0x44, 0xb8, 0xda, 0x1b, 0x9f, 0xcf, 0xc3, 0xb2, 0x94, 0x52, 0xaa,
	0x56, 0xea, 0x3d, 0xa2, 0xa2, 0xe3, 0x46, 0x94, 0x08, 0xae, 0x68, 0x99, 0x4a, 0xbd, 0x12, 0xe3,
	0x91, 0x84, 0x40, 0x77, 0xe1, 0x39, 0x1e, 0xbb, 0x14, 0x4d, 0xcd, 0xc4, 0xd0, 0x41, 0xd9, 0xf3,
	0x33, 0x7c, 0xd8, 0xe3, 0xbc, 0x1b, 0x5b, 0xfd, 0xab, 0x30, 0x77, 0x6a, 0x9c, 0x76, 0x02, 0x15,
	0x35, 0x08, 0x8d, 0x0c, 0x5a, 0x57, 0x1e, 0x61, 0x0b, 0xca, 0x92, 0xa2, 0x9a, 0x48, 0xd5, 0x94,
	0x44, 0x92, 0x08, 0x92, 0x48, 0xf6, 0xcf, 0xf3, 0x70, 0x4d, 0xd9, 0xc7, 0xaa, 0xef, 0x6f, 0xc5,
	0xda, 0x1a, 0xdf, 0x4e, 0xde, 0x83, 0x2b, 0xbd, 0x90, 0x1d, 0x10, 0x1f, 0x87, 0xe6, 0x2c, 0x53,
	0x9a, 0xca, 0x6c, 0x0c, 0xa3, 0x8f, 0x73, 0x17, 0xaa, 0xf1, 0x2d, 0x17, 0x62, 0xce, 0x8d, 0xc1,
	0xbc, 0xfa, 0xe4, 0xb8, 0x71, 0x73, 0x2c, 0x7f, 0xbc, 0xaa, 0xc7, 0x39, 0x15, 0x73, 0x37, 0xca,
	0x86, 0xd4, 0xba, 0xb9, 0x86, 0x13, 0x3f, 0x9b, 0x46, 0xeb, 0xfa, 0x26, 0x56, 0xba, 0x70, 0xa0,
	0x1a, 0xdf, 0xb8, 0x0a, 0x32, 0xa5, 0x9d, 0x54, 0xcc, 0xa5, 0xab, 0x30, 0xdf, 0x07, 0x35, 0x83,
	0xab, 0x2f, 0x24, 0xed, 0xce, 0xbf, 0x7d, 0x72, 0xdc, 0x28, 0x49, 0xf3, 0xb9, 0xfc, 0xa5, 0xa4,
	0xa2, 0x85, 0x3d, 0x79, 0x31, 0x7d, 0x00, 0x7a, 0x1e, 0x83, 0x5c, 0x54, 0xc8, 0xdf, 0x39, 0x39,
	0x6e, 0x94, 0x95, 0x5e, 0x2f, 0x0f, 0xad, 0xe3, 0x03, 0x85, 0xfd, 0x08, 0x66, 0x93, 0x60, 0x41,
	0x29, 0xac, 0x94, 0x52, 0x61, 0xd5, 0x38, 0xc4, 0x90, 0x2d, 0xfb, 0x37, 0x39, 0x98, 0x55, 0xec,
	0x7c, 0x9f, 0x88, 0x8e, 0x1f, 0x7a, 0x87, 0x5f, 0x3c, 0x33, 0x5f, 0x82, 0x6a, 0xd3, 0xe3, 0x84,
	0xbb, 0x3d, 0x46, 0xa8, 0xd0, 0xcc, 0xb4, 0x9c, 0x8a, 0xea, 0xdb, 0x51, 0x5d, 0x3a, 0x0e, 0x3b,
	0x0a, 0x02, 0x2c, 0xc2, 0x23, 0xc5, 0xb2, 0xea, 0xda, 0xb2, 0x99, 0xf5, 0xe5, 0x31, 0x66, 0xdd,
	0xc0, 0x2d, 0x67, 0x00, 0x30, 0x70, 0x98, 0xf9, 0x0b, 0x1d, 0xe6, 0x3b, 0x23, 0x5e, 0x30, 0x65,
	0x14, 0x30, 0xe4, 0x22, 0xb7, 0x40, 0x35, 0xb4, 0xff, 0x2f, 0xa6, 0x74, 0x33, 0x12, 0x41, 0x79,
	0x7d, 0x17, 0xae, 0x93, 0xa0, 0xe7, 0x76, 0x19, 0xe7, 0xae, 0x0c, 0xa5, 0x71, 0x4b, 0x10, 0x46,
	0x0d, 0x4b, 0x2e, 0x8d, 0x7b, 0x8d, 0x04, 0xbd, 0x2d, 0xc6, 0xf9, 0x4e, 0x82, 0x64, 0x7f, 0x92,
	0x87, 0x67, 0x14, 0x53, 0x76, 0x30, 0xf5, 0x09, 0x6d, 0xa7, 0xf0, 0x65, 0xaf, 0x43, 0xb5, 0xa7,
	0x07, 0xbb, 0x72, 0x2e, 0xc5, 0x97, 0x2b, 0x77, 0x5e, 0x5c, 0xd6, 0x13, 0x9f, 0xc6, 0xdd, 0x3b,
	0xea, 0x61, 0xa7, 0x62, 0x06, 0xc8, 0xc6, 0xff, 0x8b, 0xcf, 0x3a, 0x63, 0xaa, 0xf9, 0x69, 0x98,
	0xea, 0x19, 0x57, 0x58, 0x98, 0xba, 0x2b, 0x2c, 0xfe, 0xd7, 0x5c, 0x61, 0x69, 0x8a, 0xae, 0xd0,
	0xfe, 0x1e, 0x54, 0x14, 0x11, 0x37, 0x18, 0xf5, 0x04, 0x1e, 0x9f, 0x7e, 0x89, 0x9d, 0x67, 0x2f,
	0xb2, 0x73, 0xdb, 0x35, 0xf1, 0xac, 0x4c, 0x43, 0xc7, 0x07, 0xbf, 0x01, 0x85, 0x5d, 0xe1, 0x89,
	0x88, 0x1b, 0x56, 0x5f, 0x8b, 0x59, 0x2d, 0xe3, 0x00, 0xf5, 0xc2, 0x31, 0x02, 0xf6, 0x96, 0x4e,
	0x71, 0x65, 0x0a, 0x78, 0x89, 0x14, 0xf7, 0x59, 0x28, 0x18, 0xc5, 0x67, 0x95, 0x43, 0x34, 0x2d,
	0xfb, 0x67, 0x19, 0xa8, 0xaa, 0xf5, 0x3a, 0xf8, 0xd0, 0x0b, 0x7d, 0x45, 0xe8, 0x26, 0xa3, 0xbe,
	0x1b, 0xaa, 0xb6, 0x49, 0xb8, 0x2e, 0x4f, 0x68, 0x89, 0xa1, 0x21, 0xd1, 0x3d, 0xa8, 0xaa, 0x80,
	0x48, 0x23, 0xca, 0x1d, 0x5a, 0x8b, 0x95, 0x3b, 0x57, 0x86, 0x76, 0xb8, 0x1a, 0xc4, 0xab, 0xad,
	0x48, 0x49, 0xb3, 0x14, 0xfb, 0x87, 0x19, 0xa3, 0x2a, 0x07, 0xef, 0x47, 0xd4, 0x47, 0x08, 0x72,
	0x2d, 0xe6, 0xeb, 0xf4, 0x75, 0xd6, 0x51, 0xcf, 0x72, 0x5f, 0x3a, 0xc7, 0xd0, 0xd7, 0x87, 0x63,
	0x5a, 0x03, 0x6d, 0x59, 0x17, 0x7a, 0xe5, 0xaf, 0x82, 0x15, 0x47, 0xe7, 0x95, 0x3b, 0x95, 0x58,
	0xe8, 0x3e, 0xc6, 0x71, 0xda, 0xb3, 0x8f, 0xb1, 0xfd, 0xbb, 0x8c, 0xd1, 0xe9, 0x1a, 0xa3, 0x3e,
	0x7a, 0x90, 0x9c, 0x64, 0xca, 0xb3, 0x31, 0xc3, 0xd1, 0x4d, 0x28, 0xab, 0x93, 0x1e, 0x72, 0x66,
	0x57, 0xcd, 0xa1, 0xc8, 0x89, 0x94, 0x03, 0x2b, 0x35, 0xcd, 0x93, 0xdc, 0x90, 0x34, 0x06, 0x7a,
	0xfe, 0x86, 0x44, 0x7f, 0x93, 0xda, 0xff, 0xcc, 0x40, 0xf1, 0x81, 0xc7, 0x77, 0x34, 0xa9, 0xbe,
	0x90, 0x0a, 0xc8, 0x48, 0x99, 0xc3, 0x9a, 0xb4, 0xcc, 0x31, 0x92, 0x76, 0x5b, 0x26, 0xed, 0xb6,
	0xef, 0x42, 0x49, 0x69, 0xe4, 0x81, 0xc7, 0xd1, 0x12, 0xe4, 0x25, 0x6b, 0x78, 0x3d, 0x33, 0x42,
	0x2c, 0x73, 0x0a, 0xf1, 0x3e, 0x95, 0x88, 0xfd, 0xc9, 0x80, 0xee, 0xaa, 0x16, 0x85, 0x76, 0xe0,
	0xfa, 0x53, 0xca, 0x52, 0xe6, 0xc4, 0x9e, 0x37, 0x50, 0x46, 0x78, 0x7d, 0x20, 0x60, 0x50, 0x51,
	0x78, 0xe6, 0xcd, 0xb8, 0x7e, 0xe2, 0x01, 0x3c, 0xab, 0xf3, 0xde, 0x56, 0x07, 0xfb, 0x51, 0x17,
	0xfb, 0x0f, 0x23, 0xd1, 0x64, 0x92, 0xe6, 0xb7, 0xa0, 0xa0, 0x53, 0x2b, 0xb3, 0x8a, 0x9a, 0x59,
	0xc5, 0x5e, 0xff, 0x61, 0x24, 0x36, 0x05, 0x0e, 0xe2, 0x2d, 0xa9, 0xfc, 0xca, 0x5e, 0x37, 0x21,
	0xd8, 0x2e, 0x6e, 0x45, 0xa1, 0xbc, 0x50, 0x6b, 0x60, 0x05, 0xbc, 0xad, 0xd9, 0xe9, 0xc8, 0x47,
	0xb4, 0x00, 0xd9, 0x0b, 0xd6, 0x93, 0x15, 0x7d, 0x9b, 0x02, 0x68, 0x90, 0xae, 0xc7, 0x3b, 0xe3,
	0xbb, 0xad, 0x7b, 0x50, 0xe5, 0x72, 0x84, 0x9b, 0xf8, 0x96, 0x0b, 0x4c, 0x5b, 0x49, 0xea, 0x9b,
	0xc3, 0xfe, 0x49, 0x6c, 0xda, 0x6f, 0x84, 0xa1, 0x27, 0xbc, 0xa9, 0x16, 0x78, 0xee, 0xc6, 0x7c,
	0x38, 0xbb, 0x9a, 0x6d, 0xe6, 0xaf, 0xd5, 0xe4, 0x6a, 0x7e, 0xff, 0xf7, 0x46, 0xc9, 0x74, 0xf0,
	0x98, 0x1b, 0x7f, 0xc9, 0x18, 0x52, 0xc9, 0x54, 0x7b, 0x9a, 0x0b, 0x32, 0x4e, 0x26, 0x7b, 0x91,
	0x93, 0x39, 0x9d, 0xf2, 0x5a, 0x13, 0xa7, 0xbc, 0xf6, 0x0f, 0x32, 0x86, 0x19, 0x09, 0xb3, 0xde,
	0x85, 0x92, 0xa2, 0xe6, 0x60, 0x5f, 0xf7, 0x4e, 0x8e, 0x1b, 0x85, 0x4d, 0x7a, 0xf9, 0x9d, 0x15,
	0x24, 0x89, 0x37, 0xfd, 0x31, 0xa8, 0xf5, 0xd3, 0x8c, 0x89, 0xfc, 0xf6, 0x38, 0x7f, 0x1b, 0x1f,
	0xb5, 0x31, 0xdd, 0x8d, 0x5a, 0x2d, 0x19, 0x92, 0xbc, 0x09, 0xc5, 0x5e, 0xd4, 0x74, 0x3f, 0xc4,
	0x47, 0xb1, 0x2b, 0x7d, 0x72, 0xdc, 0xf8, 0xc6, 0x58, 0x6b, 0xd8, 0x89, 0x9a, 0x6f, 0xe3, 0x23,
	0xa7, 0xd0, 0x53, 0xff, 0x51, 0x1d, 0x8a, 0x01, 0x0e, 0x9a, 0x38, 0xd4, 0x4a, 0x2f, 0x3b, 0x71,
	0x53, 0xde, 0x0f, 0xa6, 0x34, 0xa7, 0x13, 0x01, 0xd3, 0xb2, 0x7f, 0x7d, 0x66, 0x55, 0xf7, 0x3d,
	0xd2, 0x8d, 0x42, 0x8c, 0x1a, 0xa0, 0x0a, 0x5a, 0xa6, 0x74, 0x65, 0xcc, 0x08, 0x64, 0x97, 0xae,
	0x59, 0xa1, 0xaf, 0x00, 0x10, 0x2e, 0xd5, 0xd4, 0xf2, 0xb8, 0xf6, 0x96, 0x25, 0xa7, 0x4c, 0xf8,
	0x23, 0xdd, 0x21, 0xc7, 0x37, 0xbb, 0x5e, 0x80, 0x5d, 0xb9, 0x5e, 0xa9, 0x48, 0xb9, 0x1e, 0x50,
	0x5d, 0xef, 0xc8, 0x1e, 0xe9, 0xd1, 0x42, 0xa9, 0x0e, 0x1d, 0x2c, 0x3a, 0xba, 0x31, 0xb4, 0xd0,
	0xfc, 0xc8, 0x42, 0x7f, 0x94, 0x81, 0xb9, 0xd1, 0x85, 0x6e, 0x63, 0x11, 0x92, 0xd6, 0x14, 0x4f,
	0xef, 0x26, 0xa0, 0x00, 0xfb, 0xc4, 0xa3, 0xae, 0x1f, 0x85, 0x9e, 0x0c, 0xd7, 0xdd, 0x80, 0x9b,
	0x38, 0xa1, 0xa6, 0xdf, 0x6c, 0x98, 0x17, 0xdb, 0x5c, 0x9a, 0xee, 0xf0, 0xc9, 0x71, 0xd2, 0x8e,
	0x57, 0x34, 0x4d, 0x9b, 0xb9, 0xdc, 0x9a, 0x7e, 0x15, 0x97, 0xbb, 0x95, 0xff, 0x52, 0x69, 0x1e,
	0xda, 0x83, 0xaa, 0xc4, 0x4e, 0xc2, 0xe8, 0x8c, 0x4a, 0xf4, 0x6e, 0x3f, 0x39, 0x6e, 0xdc, 0x1a,
	0xc3, 0x9a, 0x56, 0x5b, 0xad, 0x24, 0xde, 0x97, 0x30, 0x71, 0x18, 0xfd, 0x52, 0xec, 0xf1, 0x4c,
	0x7a, 0xa9, 0x57, 0xa4, 0x7d, 0x9b, 0x49, 0x2f, 0x07, 0x21, 0x89, 0x35, 0x1c, 0x92, 0xd8, 0x1d,
	0x78, 0x2e, 0x89, 0x0c, 0xd7, 0xbc, 0xae, 0x47, 0x5b, 0x78, 0xbd, 0xe3, 0xd1, 0x36, 0xf6, 0xd1,
	0x6b, 0xa0, 0x02, 0x1f, 0xb7, 0xa5, 0xda, 0xc6, 0xef, 0x9e, 0x76, 0x5c, 0xda, 0xa4, 0x40, 0x0a,
	0xea, 0x71, 0xe7, 0x05, 0x3f, 0xf6, 0x6f, 0xb3, 0xc6, 0xbb, 0xee, 0x1e, 0x12, 0xd1, 0xea, 0xa0,
	0x1d, 0x00, 0xc1, 0x26, 0x3f, 0x88, 0xb2, 0x60, 0xf1, 0x31, 0xec, 0x42, 0x75, 0x3f, 0x64, 0x41,
	0x82, 0x99, 0x4d, 0x9b, 0x4b, 0x49, 0x94, 0x18, 0xf4, 0x65, 0xc8, 0x35, 0xa3, 0x30, 0x8e, 0x70,
	0x9e, 0x56, 0x22, 0x54, 0xef, 0x07, 0x3c, 0xcb, 0x4d, 0xfe, 0xc1, 0xe1, 0xdf, 0x59, 0xb8, 0x32,
	0x74, 0x54, 0xef, 0x7d, 0xeb, 0xde, 0x97, 0xa7, 0x75, 0xbe, 0x55, 0xae, 0x43, 0x2e, 0x20, 0xe9,
	0xeb, 0x68, 0x6a, 0xb0, 0xfd, 0xc7, 0xf8, 0x5e, 0xda, 0x26, 0x54, 0xac, 0xc9, 0x25, 0xde, 0x86,
	0x02, 0x8f, 0x7a, 0xbd, 0xae, 0xf6, 0x64, 0x57, 0x92, 0xb8, 0x2b, 0x16, 0xd8, 0x55, 0x2f, 0x55,
	0x40, 0x6c, 0x04, 0xa5, 0x13, 0xf5, 0x31, 0x65, 0x81, 0x61, 0xbe, 0x6e, 0x0c, 0xc5, 0xe6, 0xd6,
	0x64, 0xb1, 0xf9, 0xc0, 0xb2, 0x72, 0x23, 0x96, 0xf5, 0xb1, 0x05, 0x75, 0xed, 0xfc, 0x42, 0xcf,
	0xc7, 0xab, 0x2d, 0x15, 0x8d, 0x6e, 0x98, 0x0f, 0x2d, 0x53, 0xcb, 0x0c, 0x92, 0xc0, 0x3d, 0xfb,
	0xb9, 0x81, 0xfb, 0x99, 0x6a, 0x81, 0x35, 0x95, 0x6a, 0xc1, 0xe9, 0x5a, 0x49, 0x6e, 0x1a, 0xb5,
	0x92, 0x84, 0x89, 0xf9, 0xc9, 0xed, 0xf6, 0x13, 0x0b, 0x9e, 0x3f, 0xa3, 0x88, 0xa4, 0x0a, 0xf9,
	0xa5, 0x26, 0xfe, 0x77, 0x9a, 0xf8, 0x53, 0x5c, 0x03, 0xde, 0x62, 0x1e, 0x7d, 0xd8, 0xc3, 0x14,
	0x35, 0x61, 0xae, 0xc5, 0xba, 0x5d, 0x4f, 0xe0, 0xd0, 0xeb, 0xba, 0xe6, 0x33, 0x24, 0x4e, 0x5d,
	0x4b, 0xb8, 0x3e, 0x00, 0xdb, 0x88, 0xb1, 0xd0, 0xeb, 0x50, 0x1b, 0x9a, 0xe3, 0x73, 0x75, 0x74,
	0x75, 0x20, 0xac, 0xcb, 0xa7, 0x1d, 0x78, 0x6e, 0xd0, 0x45, 0xbe, 0xaf, 0x23, 0x0c, 0x15, 0x4f,
	0xa4, 0x75, 0x1d, 0xcf, 0x9e, 0xc1, 0x73, 0xe4, 0x5f, 0x19, 0xd8, 0xfb, 0xb8, 0x29, 0x5c, 0xc2,
	0x79, 0x84, 0xfd, 0xd4, 0x15, 0x42, 0x89, 0xb1, 0xa9, 0x20, 0xd0, 0x7d, 0xc8, 0xb3, 0x43, 0x8a,
	0xc3, 0xd4, 0x95, 0x41, 0x3d, 0x1c, 0xdd, 0x85, 0xaa, 0xfe, 0x7e, 0x3a, 0x54, 0x94, 0x3e, 0xe7,
	0xfc, 0x2a, 0x5a, 0x70, 0xd5, 0x14, 0x0b, 0xf2, 0xc3, 0x15, 0xbf, 0x89, 0xd8, 0xf3, 0xcb, 0xf8,
	0x83, 0xbf, 0x64, 0x8f, 0x83, 0x7b, 0xde, 0x51, 0x80, 0xa9, 0x38, 0x45, 0xa1, 0x43, 0x63, 0xd7,
	0x74, 0x0a, 0x14, 0x8a, 0x7d, 0x04, 0x9d, 0x98, 0x42, 0xb1, 0x62, 0x43, 0xdc, 0xf3, 0x92, 0x5f,
	0x3f, 0xa4, 0x53, 0xac, 0xa3, 0x20, 0x06, 0x8a, 0xcd, 0x4d, 0xa6, 0xd8, 0x69, 0x2a, 0xe8, 0xcf,
	0x96, 0x31, 0xef, 0xbd, 0x37, 0x1f, 0x3a, 0xef, 0x78, 0x01, 0x46, 0x08, 0x72, 0xd4, 0x0b, 0xb0,
	0xc9, 0x8c, 0xd4, 0x33, 0xda, 0x80, 0xbc, 0x42, 0x32, 0xa1, 0xcd, 0xf2, 0x93, 0xe3, 0xc6, 0xd2,
	0x58, 0x33, 0xad, 0xcb, 0x5e, 0x47, 0x0f, 0x46, 0x6f, 0x41, 0x71, 0x52, 0xe7, 0x19, 0x03, 0xa0,
	0x0f, 0xa0, 0x16, 0xe2, 0x36, 0xe1, 0xc2, 0x64, 0x0f, 0x13, 0x7c, 0x84, 0xbf, 0x3a, 0x0c, 0xa4,
	0x8b, 0x03, 0xa5, 0xfd, 0x88, 0xfa, 0xaa, 0xc0, 0x95, 0x32, 0x14, 0x2a, 0x4a, 0x80, 0xd5, 0x40,
	0x45, 0x1a, 0xb8, 0xdf, 0x23, 0x21, 0x56, 0xe6, 0x67, 0x39, 0xa6, 0x85, 0x1e, 0xc4, 0x5c, 0x28,
	0xa6, 0x0d, 0x40, 0xf5, 0x78, 0xfb, 0x5e, 0x52, 0x1f, 0x12, 0xdb, 0x24, 0x20, 0x21, 0xaa, 0x81,
	0x95, 0x24, 0x8d, 0x8e, 0x7c, 0x94, 0xc1, 0xd4, 0x81, 0xd7, 0x8d, 0x70, 0x1c, 0x4c, 0xa9, 0x86,
	0xfd, 0xc8, 0x7c, 0x79, 0xde, 0xc5, 0x42, 0x26, 0xae, 0x97, 0x1a, 0x2c, 0x33, 0xf2, 0x11, 0x55,
	0x26, 0x8a, 0xb1, 0x17, 0x4d, 0x05, 0xee, 0x3d, 0x1c, 0x72, 0xc2, 0xa8, 0x94, 0x3c, 0xd0, 0x8f,
	0x06, 0x35, 0x6e, 0x2e, 0xdd, 0x82, 0xb9, 0xa7, 0x7d, 0xd5, 0x41, 0x45, 0xb0, 0x3c, 0xdf, 0xaf,
	0xcd, 0xa0, 0x2a, 0x94, 0x62, 0xd7, 0x50, 0xcb, 0x2c, 0x6d, 0x41, 0x29, 0xae, 0x9b, 0xa2, 0x59,
	0x53, 0x5b, 0x95, 0x66, 0x55, 0x9b, 0x41, 0xd7, 0x60, 0xd6, 0x14, 0xb5, 0x45, 0x14, 0x52, 0xec,
	0xd7, 0x32, 0xe8, 0xea, 0x48, 0x9d, 0xbb, 0x96, 0x4d, 0x86, 0xb4, 0x18, 0x17, 0x35, 0x6b, 0x69,
	0x11, 0xd0, 0xd9, 0xf0, 0x13, 0x95, 0x74, 0x00, 0x5c, 0x9b, 0x91, 0x4f, 0x32, 0xbc, 0xae, 0x65,
	0xd6, 0x36, 0x3f, 0x3d, 0x99, 0xcf, 0x7c, 0x76, 0x32, 0x9f, 0xf9, 0xc7, 0xc9, 0x7c, 0xe6, 0xc7,
	0x8f, 0xe7, 0x67, 0x3e, 0x7b, 0x3c, 0x3f, 0xf3, 0xd7, 0xc7, 0xf3, 0x33, 0x1f, 0xac, 0x5c, 0x4c,
	0xdd, 0x33, 0xbf, 0x73, 0x6b, 0x16, 0xd4, 0xcf, 0xd8, 0xbe, 0xf9, 0x9f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xd7, 0x99, 0x30, 0x32, 0xda, 0x27, 0x00, 0x00,
}

func (m *PoolMod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolMod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolMod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssetAdd {
		i--
		if m.AssetAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.AssetAmt.Size()
		i -= size
		if _, err := m.AssetAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.RuneAdd {
		i--
		if m.RuneAdd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.RuneAmt.Size()
		i -= size
		if _, err := m.RuneAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventLimitOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLimitOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLimitOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventStreamingSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventStreamingSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventStreamingSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailedSwapReasons) > 0 {
		for iNdEx := len(m.FailedSwapReasons) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FailedSwapReasons[iNdEx])
			copy(dAtA[i:], m.FailedSwapReasons[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FailedSwapReasons[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.FailedSwaps) > 0 {
		dAtA5 := make([]byte, len(m.FailedSwaps)*10)
		var j4 int
		for _, num := range m.FailedSwaps {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintTypeEvents(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.Out.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.In.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.Deposit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.TradeTarget.Size()
		i -= size
		if _, err := m.TradeTarget.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.LastHeight != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.LastHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.Count != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if m.Quantity != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Quantity))
		i--
		dAtA[i] = 0x18
	}
	if m.Interval != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.PoolSlip.Size()
		i -= size
		if _, err := m.PoolSlip.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.StreamingSwapCount != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.StreamingSwapCount))
		i--
		dAtA[i] = 0x58
	}
	if m.StreamingSwapQuantity != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.StreamingSwapQuantity))
		i--
		dAtA[i] = 0x50
	}
	{
		size := m.SynthUnits.Size()
		i -= size
		if _, err := m.SynthUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.EmitAsset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.OutTxs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.LiquidityFeeInRune.Size()
		i -= size
		if _, err := m.LiquidityFeeInRune.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.LiquidityFee.Size()
		i -= size
		if _, err := m.LiquidityFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.SwapSlip.Size()
		i -= size
		if _, err := m.SwapSlip.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SwapTarget.Size()
		i -= size
		if _, err := m.SwapTarget.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventAddLiquidity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAddLiquidity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAddLiquidity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AssetTxID) > 0 {
		i -= len(m.AssetTxID)
		copy(dAtA[i:], m.AssetTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetTxID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RuneTxID) > 0 {
		i -= len(m.RuneTxID)
		copy(dAtA[i:], m.RuneTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneTxID)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.AssetAmount.Size()
		i -= size
		if _, err := m.AssetAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.RuneAmount.Size()
		i -= size
		if _, err := m.RuneAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.ProviderUnits.Size()
		i -= size
		if _, err := m.ProviderUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ImpLossProtection.Size()
		i -= size
		if _, err := m.ImpLossProtection.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.EmitRune.Size()
		i -= size
		if _, err := m.EmitRune.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.EmitAsset.Size()
		i -= size
		if _, err := m.EmitAsset.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Asymmetry.Size()
		i -= size
		if _, err := m.Asymmetry.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.BasisPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BasisPoints))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.ProviderUnits.Size()
		i -= size
		if _, err := m.ProviderUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventPendingLiquidity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPendingLiquidity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPendingLiquidity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetTxID) > 0 {
		i -= len(m.AssetTxID)
		copy(dAtA[i:], m.AssetTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetTxID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RuneTxID) > 0 {
		i -= len(m.RuneTxID)
		copy(dAtA[i:], m.RuneTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneTxID)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.AssetAmount.Size()
		i -= size
		if _, err := m.AssetAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.RuneAmount.Size()
		i -= size
		if _, err := m.RuneAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PendingType != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.PendingType))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventDonate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDonate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDonate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PoolAmt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolAmt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolAmt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PoolRewards) > 0 {
		for iNdEx := len(m.PoolRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PoolRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.BondReward.Size()
		i -= size
		if _, err := m.BondReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventRefund) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRefund) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRefund) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventBond) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBond) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBond) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TxIn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BondType != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.BondType))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GasPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.AssetAmt.Size()
		i -= size
		if _, err := m.AssetAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.RuneAmt.Size()
		i -= size
		if _, err := m.RuneAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventGas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventGas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventGas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventReserve) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReserve) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventReserve) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.InTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ReserveContributor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventScheduledOutbound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventScheduledOutbound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventScheduledOutbound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.OutTx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSecurity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSecurity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSecurity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSlash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSlash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSlash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SlashAmount) > 0 {
		for iNdEx := len(m.SlashAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SlashAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Pool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventErrata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventErrata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventErrata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypeEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SynthUnits.Size()
		i -= size
		if _, err := m.SynthUnits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventOutbound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventOutbound) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventOutbound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.InTxID) > 0 {
		i -= len(m.InTxID)
		copy(dAtA[i:], m.InTxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.InTxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenSuccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenSuccess) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenSuccess) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Members[iNdEx])
			copy(dAtA[i:], m.Members[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Members[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenFailure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Round) > 0 {
		i -= len(m.Round)
		copy(dAtA[i:], m.Round)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Round)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BlameNodes) > 0 {
		for iNdEx := len(m.BlameNodes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BlameNodes[iNdEx])
			copy(dAtA[i:], m.BlameNodes[iNdEx])
			i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.BlameNodes[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsUnicast {
		i--
		if m.IsUnicast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.FailReason) > 0 {
		i -= len(m.FailReason)
		copy(dAtA[i:], m.FailReason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FailReason)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeygenMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeygenMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeygenMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MedianDurationMs != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.MedianDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventTssKeysignMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTssKeysignMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTssKeysignMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MedianDurationMs != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.MedianDurationMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSlashPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSlashPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSlashPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SlashPoints != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.SlashPoints))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeAddress) > 0 {
		i -= len(m.NodeAddress)
		copy(dAtA[i:], m.NodeAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.NodeAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPoolBalanceChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPoolBalanceChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPoolBalanceChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.PoolChange.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventSwitch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwitch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwitch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Burn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToAddress) > 0 {
		i -= len(m.ToAddress)
		copy(dAtA[i:], m.ToAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.ToAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwitchV87) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwitchV87) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwitchV87) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Mint.Size()
		i -= size
		if _, err := m.Mint.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Burn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToAddress) > 0 {
		i -= len(m.ToAddress)
		copy(dAtA[i:], m.ToAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.ToAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMintBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMintBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMintBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if m.Supply != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Supply))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventTradeAccountDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTradeAccountDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTradeAccountDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventTradeAccountWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTradeAccountWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTradeAccountWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RuneAddress) > 0 {
		i -= len(m.RuneAddress)
		copy(dAtA[i:], m.RuneAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.RuneAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssetAddress) > 0 {
		i -= len(m.AssetAddress)
		copy(dAtA[i:], m.AssetAddress)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.AssetAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventLoanOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLoanOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLoanOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.TargetAsset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.DebtIssued.Size()
		i -= size
		if _, err := m.DebtIssued.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.CollateralizationRatio.Size()
		i -= size
		if _, err := m.CollateralizationRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.CollateralAsset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.CollateralDeposited.Size()
		i -= size
		if _, err := m.CollateralDeposited.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventLoanRepayment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventLoanRepayment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventLoanRepayment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxID) > 0 {
		i -= len(m.TxID)
		copy(dAtA[i:], m.TxID)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.TxID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.DebtRepaid.Size()
		i -= size
		if _, err := m.DebtRepaid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.CollateralAsset.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.CollateralWithdrawn.Size()
		i -= size
		if _, err := m.CollateralWithdrawn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventTHORName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventTHORName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventTHORName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Expire != 0 {
		i = encodeVarintTypeEvents(dAtA, i, uint64(m.Expire))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.FundAmt.Size()
		i -= size
		if _, err := m.FundAmt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.RegistrationFee.Size()
		i -= size
		if _, err := m.RegistrationFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypeEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSetMimir) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetMimir) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetMimir) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSetNodeMimir) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSetNodeMimir) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSetNodeMimir) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypeEvents(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypeEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypeEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PoolMod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.RuneAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.RuneAdd {
		n += 2
	}
	l = m.AssetAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.AssetAdd {
		n += 2
	}
	return n
}

func (m *EventLimitOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Source.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Target.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventStreamingSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.Interval != 0 {
		n += 1 + sovTypeEvents(uint64(m.Interval))
	}
	if m.Quantity != 0 {
		n += 1 + sovTypeEvents(uint64(m.Quantity))
	}
	if m.Count != 0 {
		n += 1 + sovTypeEvents(uint64(m.Count))
	}
	if m.LastHeight != 0 {
		n += 1 + sovTypeEvents(uint64(m.LastHeight))
	}
	l = m.TradeTarget.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Deposit.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.In.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Out.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.FailedSwaps) > 0 {
		l = 0
		for _, e := range m.FailedSwaps {
			l += sovTypeEvents(uint64(e))
		}
		n += 1 + sovTypeEvents(uint64(l)) + l
	}
	if len(m.FailedSwapReasons) > 0 {
		for _, s := range m.FailedSwapReasons {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventSwap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SwapTarget.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SwapSlip.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.LiquidityFee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.LiquidityFeeInRune.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.OutTxs.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SynthUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.StreamingSwapQuantity != 0 {
		n += 1 + sovTypeEvents(uint64(m.StreamingSwapQuantity))
	}
	if m.StreamingSwapCount != 0 {
		n += 1 + sovTypeEvents(uint64(m.StreamingSwapCount))
	}
	l = m.PoolSlip.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventAddLiquidity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ProviderUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.RuneAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.AssetAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.RuneTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ProviderUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.BasisPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.BasisPoints))
	}
	l = m.Asymmetry.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.EmitRune.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.ImpLossProtection.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventPendingLiquidity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.PendingType != 0 {
		n += 1 + sovTypeEvents(uint64(m.PendingType))
	}
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.RuneAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.AssetAmount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.RuneTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.AssetTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventDonate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTypeEvents(uint64(m.Status))
	}
	return n
}

func (m *PoolAmt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Amount != 0 {
		n += 1 + sovTypeEvents(uint64(m.Amount))
	}
	return n
}

func (m *EventRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BondReward.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.PoolRewards) > 0 {
		for _, e := range m.PoolRewards {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventRefund) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTypeEvents(uint64(m.Code))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventBond) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.BondType != 0 {
		n += 1 + sovTypeEvents(uint64(m.BondType))
	}
	l = m.TxIn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *GasPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.RuneAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.AssetAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Count != 0 {
		n += 1 + sovTypeEvents(uint64(m.Count))
	}
	return n
}

func (m *EventGas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventReserve) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReserveContributor.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.InTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventScheduledOutbound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OutTx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventSecurity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Tx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventSlash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pool.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if len(m.SlashAmount) > 0 {
		for _, e := range m.SlashAmount {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventErrata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	return n
}

func (m *EventFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Fee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.SynthUnits.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventOutbound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InTxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Tx.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventTssKeygenSuccess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, s := range m.Members {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	if m.Height != 0 {
		n += 1 + sovTypeEvents(uint64(m.Height))
	}
	return n
}

func (m *EventTssKeygenFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FailReason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.IsUnicast {
		n += 2
	}
	if len(m.BlameNodes) > 0 {
		for _, s := range m.BlameNodes {
			l = len(s)
			n += 1 + l + sovTypeEvents(uint64(l))
		}
	}
	l = len(m.Round)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovTypeEvents(uint64(m.Height))
	}
	return n
}

func (m *EventTssKeygenMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.MedianDurationMs != 0 {
		n += 1 + sovTypeEvents(uint64(m.MedianDurationMs))
	}
	return n
}

func (m *EventTssKeysignMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.MedianDurationMs != 0 {
		n += 1 + sovTypeEvents(uint64(m.MedianDurationMs))
	}
	return n
}

func (m *EventSlashPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	if m.SlashPoints != 0 {
		n += 1 + sovTypeEvents(uint64(m.SlashPoints))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventPoolBalanceChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PoolChange.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSwitch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Burn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSwitchV87) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Burn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Mint.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	return n
}

func (m *EventMintBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Supply != 0 {
		n += 1 + sovTypeEvents(uint64(m.Supply))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventTradeAccountDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventTradeAccountWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.Asset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.AssetAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.RuneAddress)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventLoanOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollateralDeposited.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.CollateralAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.CollateralizationRatio.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.DebtIssued.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.TargetAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventLoanRepayment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollateralWithdrawn.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.CollateralAsset.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.DebtRepaid.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.TxID)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventTHORName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = m.RegistrationFee.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	l = m.FundAmt.Size()
	n += 1 + l + sovTypeEvents(uint64(l))
	if m.Expire != 0 {
		n += 1 + sovTypeEvents(uint64(m.Expire))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSetMimir) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventSetNodeMimir) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func (m *EventVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypeEvents(uint64(l))
	}
	return n
}

func sovTypeEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypeEvents(x uint64) (n int) {
	return sovTypeEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PoolMod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolMod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolMod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RuneAdd = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAdd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AssetAdd = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLimitOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLimitOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLimitOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventStreamingSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventStreamingSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventStreamingSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeight", wireType)
			}
			m.LastHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeTarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TradeTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.In.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Out", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Out.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypeEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FailedSwaps = append(m.FailedSwaps, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypeEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypeEvents
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypeEvents
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FailedSwaps) == 0 {
					m.FailedSwaps = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypeEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FailedSwaps = append(m.FailedSwaps, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedSwaps", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedSwapReasons", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedSwapReasons = append(m.FailedSwapReasons, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapTarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwapTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapSlip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwapSlip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityFeeInRune", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityFeeInRune.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutTxs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynthUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SynthUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamingSwapQuantity", wireType)
			}
			m.StreamingSwapQuantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamingSwapQuantity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamingSwapCount", wireType)
			}
			m.StreamingSwapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamingSwapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolSlip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolSlip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAddLiquidity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAddLiquidity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAddLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProviderUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneTxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProviderUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasisPoints", wireType)
			}
			m.BasisPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasisPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asymmetry", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asymmetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitAsset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitRune", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmitRune.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImpLossProtection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ImpLossProtection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPendingLiquidity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPendingLiquidity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPendingLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingType", wireType)
			}
			m.PendingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingType |= PendingLiquidityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneTxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDonate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDonate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDonate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PoolStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolAmt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolAmt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolAmt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BondReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolRewards = append(m.PoolRewards, PoolAmt{})
			if err := m.PoolRewards[len(m.PoolRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRefund) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRefund: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRefund: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBond) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBond: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBond: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondType", wireType)
			}
			m.BondType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BondType |= BondType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuneAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AssetAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventGas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventGas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventGas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, GasPool{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReserve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReserve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReserve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveContributor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReserveContributor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventScheduledOutbound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventScheduledOutbound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventScheduledOutbound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OutTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSecurity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSecurity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSlash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSlash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSlash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashAmount = append(m.SlashAmount, PoolAmt{})
			if err := m.SlashAmount[len(m.SlashAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventErrata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventErrata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventErrata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, PoolMod{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynthUnits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SynthUnits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventOutbound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventOutbound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventOutbound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InTxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenSuccess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenSuccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenSuccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = gitlab_com_thorchain_thornode_common.PubKey(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenFailure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenFailure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenFailure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnicast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnicast = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlameNodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlameNodes = append(m.BlameNodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Round = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeygenMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeygenMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeygenMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = gitlab_com_thorchain_thornode_common.PubKey(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianDurationMs", wireType)
			}
			m.MedianDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedianDurationMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTssKeysignMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTssKeysignMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTssKeysignMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedianDurationMs", wireType)
			}
			m.MedianDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedianDurationMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSlashPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSlashPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSlashPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddress = append(m.NodeAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.NodeAddress == nil {
				m.NodeAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashPoints", wireType)
			}
			m.SlashPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashPoints |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPoolBalanceChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPoolBalanceChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPoolBalanceChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolChange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwitch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwitch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwitch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = append(m.ToAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ToAddress == nil {
				m.ToAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Burn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwitchV87) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwitchV87: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwitchV87: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = append(m.ToAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ToAddress == nil {
				m.ToAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Burn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Mint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMintBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMintBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMintBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supply", wireType)
			}
			m.Supply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Supply |= MintBurnSupplyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTradeAccountDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTradeAccountDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTradeAccountDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTradeAccountWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTradeAccountWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTradeAccountWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuneAddress = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLoanOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLoanOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLoanOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralDeposited", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralDeposited.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralizationRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralizationRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtIssued", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DebtIssued.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventLoanRepayment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventLoanRepayment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventLoanRepayment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralAsset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtRepaid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DebtRepaid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxID = gitlab_com_thorchain_thornode_common.TxID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventTHORName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventTHORName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventTHORName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = gitlab_com_thorchain_thornode_common.Chain(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = gitlab_com_thorchain_thornode_common.Address(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RegistrationFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundAmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = append(m.Owner[:0], dAtA[iNdEx:postIndex]...)
			if m.Owner == nil {
				m.Owner = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetMimir) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetMimir: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetMimir: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSetNodeMimir) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSetNodeMimir: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSetNodeMimir: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypeEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypeEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypeEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypeEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypeEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypeEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypeEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypeEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypeEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypeEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypeEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypeEvents = fmt.Errorf("proto: unexpected end of group")
)
