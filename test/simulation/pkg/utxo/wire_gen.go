// Code generated by go generate; DO NOT EDIT.

package utxo

import (
  "github.com/btcsuite/btcd/wire"
  "github.com/btcsuite/btcd/chaincfg/chainhash"
  bchwire "github.com/gcash/bchd/wire"
  bchchainhash "github.com/gcash/bchd/chaincfg/chainhash"
  btcwire "github.com/btcsuite/btcd/wire"
  btcchainhash "github.com/btcsuite/btcd/chaincfg/chainhash"
  dogewire "github.com/eager7/dogd/wire"
  dogechainhash "github.com/eager7/dogd/chaincfg/chainhash"
  ltcwire "github.com/ltcsuite/ltcd/wire"
  ltcchainhash "github.com/ltcsuite/ltcd/chaincfg/chainhash"
)

func wireToBCH(tx *wire.MsgTx) *bchwire.MsgTx {
	txc := &bchwire.MsgTx{
		Version:  tx.Version,
		LockTime: tx.LockTime,
	}
	for _, rtx := range tx.TxIn {
		txi := &bchwire.TxIn{
			PreviousOutPoint: bchwire.OutPoint{
				Hash:  bchchainhash.Hash(rtx.PreviousOutPoint.Hash),
				Index: rtx.PreviousOutPoint.Index,
			},
			SignatureScript: rtx.SignatureScript,
			Sequence:        rtx.Sequence,
		}
		txc.TxIn = append(txc.TxIn, txi)
	}
	for _, stx := range tx.TxOut {
		txo := &bchwire.TxOut{
			Value:    stx.Value,
			PkScript: stx.PkScript,
		}
		txc.TxOut = append(txc.TxOut, txo)
	}
	return txc
}

func bchToWire(txc *bchwire.MsgTx) *wire.MsgTx {
	tx := &wire.MsgTx{
		Version:  txc.Version,
		LockTime: txc.LockTime,
	}
	for _, rtx := range txc.TxIn {
		txi := &wire.TxIn{
			PreviousOutPoint: wire.OutPoint{
				Hash:  chainhash.Hash(rtx.PreviousOutPoint.Hash),
				Index: rtx.PreviousOutPoint.Index,
			},
			SignatureScript: rtx.SignatureScript,
			Sequence:        rtx.Sequence,
		}
		tx.TxIn = append(tx.TxIn, txi)
	}
	for _, stx := range txc.TxOut {
		txo := &wire.TxOut{
			Value:    stx.Value,
			PkScript: stx.PkScript,
		}
		tx.TxOut = append(tx.TxOut, txo)
	}
	return tx
}

func wireToBTC(tx *wire.MsgTx) *btcwire.MsgTx {
	txc := &btcwire.MsgTx{
		Version:  tx.Version,
		LockTime: tx.LockTime,
	}
	for _, rtx := range tx.TxIn {
		txi := &btcwire.TxIn{
			PreviousOutPoint: btcwire.OutPoint{
				Hash:  btcchainhash.Hash(rtx.PreviousOutPoint.Hash),
				Index: rtx.PreviousOutPoint.Index,
			},
			SignatureScript: rtx.SignatureScript,
			Witness:         btcwire.TxWitness(rtx.Witness),
			Sequence:        rtx.Sequence,
		}
		txc.TxIn = append(txc.TxIn, txi)
	}
	for _, stx := range tx.TxOut {
		txo := &btcwire.TxOut{
			Value:    stx.Value,
			PkScript: stx.PkScript,
		}
		txc.TxOut = append(txc.TxOut, txo)
	}
	return txc
}

func btcToWire(txc *btcwire.MsgTx) *wire.MsgTx {
	tx := &wire.MsgTx{
		Version:  txc.Version,
		LockTime: txc.LockTime,
	}
	for _, rtx := range txc.TxIn {
		txi := &wire.TxIn{
			PreviousOutPoint: wire.OutPoint{
				Hash:  chainhash.Hash(rtx.PreviousOutPoint.Hash),
				Index: rtx.PreviousOutPoint.Index,
			},
			SignatureScript: rtx.SignatureScript,
			Witness:         wire.TxWitness(rtx.Witness),
			Sequence:        rtx.Sequence,
		}
		tx.TxIn = append(tx.TxIn, txi)
	}
	for _, stx := range txc.TxOut {
		txo := &wire.TxOut{
			Value:    stx.Value,
			PkScript: stx.PkScript,
		}
		tx.TxOut = append(tx.TxOut, txo)
	}
	return tx
}

func wireToDOGE(tx *wire.MsgTx) *dogewire.MsgTx {
	txc := &dogewire.MsgTx{
		Version:  tx.Version,
		LockTime: tx.LockTime,
	}
	for _, rtx := range tx.TxIn {
		txi := &dogewire.TxIn{
			PreviousOutPoint: dogewire.OutPoint{
				Hash:  dogechainhash.Hash(rtx.PreviousOutPoint.Hash),
				Index: rtx.PreviousOutPoint.Index,
			},
			SignatureScript: rtx.SignatureScript,
			Witness:         dogewire.TxWitness(rtx.Witness),
			Sequence:        rtx.Sequence,
		}
		txc.TxIn = append(txc.TxIn, txi)
	}
	for _, stx := range tx.TxOut {
		txo := &dogewire.TxOut{
			Value:    stx.Value,
			PkScript: stx.PkScript,
		}
		txc.TxOut = append(txc.TxOut, txo)
	}
	return txc
}

func dogeToWire(txc *dogewire.MsgTx) *wire.MsgTx {
	tx := &wire.MsgTx{
		Version:  txc.Version,
		LockTime: txc.LockTime,
	}
	for _, rtx := range txc.TxIn {
		txi := &wire.TxIn{
			PreviousOutPoint: wire.OutPoint{
				Hash:  chainhash.Hash(rtx.PreviousOutPoint.Hash),
				Index: rtx.PreviousOutPoint.Index,
			},
			SignatureScript: rtx.SignatureScript,
			Witness:         wire.TxWitness(rtx.Witness),
			Sequence:        rtx.Sequence,
		}
		tx.TxIn = append(tx.TxIn, txi)
	}
	for _, stx := range txc.TxOut {
		txo := &wire.TxOut{
			Value:    stx.Value,
			PkScript: stx.PkScript,
		}
		tx.TxOut = append(tx.TxOut, txo)
	}
	return tx
}

func wireToLTC(tx *wire.MsgTx) *ltcwire.MsgTx {
	txc := &ltcwire.MsgTx{
		Version:  tx.Version,
		LockTime: tx.LockTime,
	}
	for _, rtx := range tx.TxIn {
		txi := &ltcwire.TxIn{
			PreviousOutPoint: ltcwire.OutPoint{
				Hash:  ltcchainhash.Hash(rtx.PreviousOutPoint.Hash),
				Index: rtx.PreviousOutPoint.Index,
			},
			SignatureScript: rtx.SignatureScript,
			Witness:         ltcwire.TxWitness(rtx.Witness),
			Sequence:        rtx.Sequence,
		}
		txc.TxIn = append(txc.TxIn, txi)
	}
	for _, stx := range tx.TxOut {
		txo := &ltcwire.TxOut{
			Value:    stx.Value,
			PkScript: stx.PkScript,
		}
		txc.TxOut = append(txc.TxOut, txo)
	}
	return txc
}

func ltcToWire(txc *ltcwire.MsgTx) *wire.MsgTx {
	tx := &wire.MsgTx{
		Version:  txc.Version,
		LockTime: txc.LockTime,
	}
	for _, rtx := range txc.TxIn {
		txi := &wire.TxIn{
			PreviousOutPoint: wire.OutPoint{
				Hash:  chainhash.Hash(rtx.PreviousOutPoint.Hash),
				Index: rtx.PreviousOutPoint.Index,
			},
			SignatureScript: rtx.SignatureScript,
			Witness:         wire.TxWitness(rtx.Witness),
			Sequence:        rtx.Sequence,
		}
		tx.TxIn = append(tx.TxIn, txi)
	}
	for _, stx := range txc.TxOut {
		txo := &wire.TxOut{
			Value:    stx.Value,
			PkScript: stx.PkScript,
		}
		tx.TxOut = append(tx.TxOut, txo)
	}
	return tx
}
