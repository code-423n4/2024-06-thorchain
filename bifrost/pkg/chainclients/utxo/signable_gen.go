// Code generated by go generate; DO NOT EDIT.

package utxo

import (
	"encoding/base64"
  "fmt"
	"math/big"

	"github.com/cosmos/cosmos-sdk/crypto/codec"
	"github.com/rs/zerolog"
  bchec "github.com/gcash/bchd/bchec"
  btcec "github.com/btcsuite/btcd/btcec"
  dogeec "github.com/eager7/dogd/btcec"
  ltcec "github.com/ltcsuite/ltcd/btcec"

	"gitlab.com/thorchain/thornode/bifrost/tss"
	"gitlab.com/thorchain/thornode/common"
	"gitlab.com/thorchain/thornode/common/cosmos"
)

type tssSignableBCH struct {
	poolPubKey    common.PubKey
	tssKeyManager tss.ThorchainKeyManager
	log           zerolog.Logger
}

func newTssSignableBCH(poolPubKey common.PubKey, tssKeyManager tss.ThorchainKeyManager, log zerolog.Logger) *tssSignableBCH {
	return &tssSignableBCH{
		poolPubKey:    poolPubKey,
		tssKeyManager: tssKeyManager,
		log:           log,
	}
}
func (ts *tssSignableBCH) SignECDSA(payload []byte) (*bchec.Signature, error) {
	ts.log.Info().Msgf("msg to sign: %s", base64.StdEncoding.EncodeToString(payload))
	result, _, err := ts.tssKeyManager.RemoteSign(payload, ts.poolPubKey.String())
	if err != nil {
		return nil, err
	}
	var sig bchec.Signature
	sig.R = new(big.Int).SetBytes(result[:32])
	sig.S = new(big.Int).SetBytes(result[32:])

	// verify the signature
	if sig.Verify(payload, ts.GetPubKey()) {
		ts.log.Info().Msg("we can verify the signature successfully")
	} else {
		ts.log.Info().Msg("the signature can't be verified")
	}

	return &sig, nil
}
// SignSchnorr signs the given payload using Schnorr
func (ts *tssSignableBCH) SignSchnorr(payload []byte) (*bchec.Signature, error) {
	return nil, fmt.Errorf("schnorr signature not yet implemented in TSS")
}

func (ts *tssSignableBCH) GetPubKey() *bchec.PublicKey {
	cpk, err := cosmos.GetPubKeyFromBech32(cosmos.Bech32PubKeyTypeAccPub, ts.poolPubKey.String())
	if err != nil {
		ts.log.Err(err).Str("pubkey", ts.poolPubKey.String()).Msg("fail to get pubic key from the bech32 pool public key string")
		return nil
	}
	secpPubKey, err := codec.ToTmPubKeyInterface(cpk)
	if err != nil {
		ts.log.Err(err).Msgf("%s is not a secp256 k1 public key", ts.poolPubKey)
		return nil
	}
	newPubkey, err := bchec.ParsePubKey(secpPubKey.Bytes(), bchec.S256())
	if err != nil {
		ts.log.Err(err).Msg("fail to parse public key")
		return nil
	}
	return newPubkey
}

type tssSignableBTC struct {
	poolPubKey    common.PubKey
	tssKeyManager tss.ThorchainKeyManager
	log           zerolog.Logger
}

func newTssSignableBTC(poolPubKey common.PubKey, tssKeyManager tss.ThorchainKeyManager, log zerolog.Logger) *tssSignableBTC {
	return &tssSignableBTC{
		poolPubKey:    poolPubKey,
		tssKeyManager: tssKeyManager,
		log:           log,
	}
}
func (ts *tssSignableBTC) Sign(payload []byte) (*btcec.Signature, error) {
	ts.log.Info().Msgf("msg to sign: %s", base64.StdEncoding.EncodeToString(payload))
	result, _, err := ts.tssKeyManager.RemoteSign(payload, ts.poolPubKey.String())
	if err != nil {
		return nil, err
	}
	var sig btcec.Signature
	sig.R = new(big.Int).SetBytes(result[:32])
	sig.S = new(big.Int).SetBytes(result[32:])

	// verify the signature
	if sig.Verify(payload, ts.GetPubKey()) {
		ts.log.Info().Msg("we can verify the signature successfully")
	} else {
		ts.log.Info().Msg("the signature can't be verified")
	}

	return &sig, nil
}

func (ts *tssSignableBTC) GetPubKey() *btcec.PublicKey {
	cpk, err := cosmos.GetPubKeyFromBech32(cosmos.Bech32PubKeyTypeAccPub, ts.poolPubKey.String())
	if err != nil {
		ts.log.Err(err).Str("pubkey", ts.poolPubKey.String()).Msg("fail to get pubic key from the bech32 pool public key string")
		return nil
	}
	secpPubKey, err := codec.ToTmPubKeyInterface(cpk)
	if err != nil {
		ts.log.Err(err).Msgf("%s is not a secp256 k1 public key", ts.poolPubKey)
		return nil
	}
	newPubkey, err := btcec.ParsePubKey(secpPubKey.Bytes(), btcec.S256())
	if err != nil {
		ts.log.Err(err).Msg("fail to parse public key")
		return nil
	}
	return newPubkey
}

type tssSignableDOGE struct {
	poolPubKey    common.PubKey
	tssKeyManager tss.ThorchainKeyManager
	log           zerolog.Logger
}

func newTssSignableDOGE(poolPubKey common.PubKey, tssKeyManager tss.ThorchainKeyManager, log zerolog.Logger) *tssSignableDOGE {
	return &tssSignableDOGE{
		poolPubKey:    poolPubKey,
		tssKeyManager: tssKeyManager,
		log:           log,
	}
}
func (ts *tssSignableDOGE) Sign(payload []byte) (*dogeec.Signature, error) {
	ts.log.Info().Msgf("msg to sign: %s", base64.StdEncoding.EncodeToString(payload))
	result, _, err := ts.tssKeyManager.RemoteSign(payload, ts.poolPubKey.String())
	if err != nil {
		return nil, err
	}
	var sig dogeec.Signature
	sig.R = new(big.Int).SetBytes(result[:32])
	sig.S = new(big.Int).SetBytes(result[32:])

	// verify the signature
	if sig.Verify(payload, ts.GetPubKey()) {
		ts.log.Info().Msg("we can verify the signature successfully")
	} else {
		ts.log.Info().Msg("the signature can't be verified")
	}

	return &sig, nil
}

func (ts *tssSignableDOGE) GetPubKey() *dogeec.PublicKey {
	cpk, err := cosmos.GetPubKeyFromBech32(cosmos.Bech32PubKeyTypeAccPub, ts.poolPubKey.String())
	if err != nil {
		ts.log.Err(err).Str("pubkey", ts.poolPubKey.String()).Msg("fail to get pubic key from the bech32 pool public key string")
		return nil
	}
	secpPubKey, err := codec.ToTmPubKeyInterface(cpk)
	if err != nil {
		ts.log.Err(err).Msgf("%s is not a secp256 k1 public key", ts.poolPubKey)
		return nil
	}
	newPubkey, err := dogeec.ParsePubKey(secpPubKey.Bytes(), dogeec.S256())
	if err != nil {
		ts.log.Err(err).Msg("fail to parse public key")
		return nil
	}
	return newPubkey
}

type tssSignableLTC struct {
	poolPubKey    common.PubKey
	tssKeyManager tss.ThorchainKeyManager
	log           zerolog.Logger
}

func newTssSignableLTC(poolPubKey common.PubKey, tssKeyManager tss.ThorchainKeyManager, log zerolog.Logger) *tssSignableLTC {
	return &tssSignableLTC{
		poolPubKey:    poolPubKey,
		tssKeyManager: tssKeyManager,
		log:           log,
	}
}
func (ts *tssSignableLTC) Sign(payload []byte) (*ltcec.Signature, error) {
	ts.log.Info().Msgf("msg to sign: %s", base64.StdEncoding.EncodeToString(payload))
	result, _, err := ts.tssKeyManager.RemoteSign(payload, ts.poolPubKey.String())
	if err != nil {
		return nil, err
	}
	var sig ltcec.Signature
	sig.R = new(big.Int).SetBytes(result[:32])
	sig.S = new(big.Int).SetBytes(result[32:])

	// verify the signature
	if sig.Verify(payload, ts.GetPubKey()) {
		ts.log.Info().Msg("we can verify the signature successfully")
	} else {
		ts.log.Info().Msg("the signature can't be verified")
	}

	return &sig, nil
}

func (ts *tssSignableLTC) GetPubKey() *ltcec.PublicKey {
	cpk, err := cosmos.GetPubKeyFromBech32(cosmos.Bech32PubKeyTypeAccPub, ts.poolPubKey.String())
	if err != nil {
		ts.log.Err(err).Str("pubkey", ts.poolPubKey.String()).Msg("fail to get pubic key from the bech32 pool public key string")
		return nil
	}
	secpPubKey, err := codec.ToTmPubKeyInterface(cpk)
	if err != nil {
		ts.log.Err(err).Msgf("%s is not a secp256 k1 public key", ts.poolPubKey)
		return nil
	}
	newPubkey, err := ltcec.ParsePubKey(secpPubKey.Bytes(), ltcec.S256())
	if err != nil {
		ts.log.Err(err).Msg("fail to parse public key")
		return nil
	}
	return newPubkey
}
